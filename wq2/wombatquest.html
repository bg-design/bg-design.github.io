<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wombat Quest - Boom Boom Womb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="http://boomboomwomb.com/img/favicon.png">
  <link rel="icon" type="image/x-icon" href="http://boomboomwomb.com/img/favicon.ico" />
  <style>
    body { 
      margin: 0; 
      padding: 0;
      background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
      font-family: 'Arial', sans-serif;
      color: #fff;
      overflow: hidden;
    }
    
    .game-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1;
    }
    
    h1 {
      color: #ff6b35;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    
    
    canvas { 
      background: linear-gradient(45deg, #2c1810, #4a2c1a);
      border: 3px solid #ff6b35;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    .controls {
      margin-top: 15px;
      color: #ffd23f;
      font-size: 0.9em;
    }
    
    .stats-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background:black;
      padding: 15px;
      min-width: 200px;
      z-index: 100;
    }
    
    .stat-bar {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    
    .stat-label {
      width: 60px;
      color: #ffd23f;
      font-weight: bold;
    }
    
    .stat-progress {
      flex: 1;
      height: 4px;
      background: #333;
      border: 1px solid #555;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 0 0 10px;
      position: relative;
    }
    
    .stat-fill {
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 10px;
    }
    
    .stat-value {
      display: none;
    }
    
    .thirst-fill { background: linear-gradient(90deg, #00bfff, #0080ff); }
    .hunger-fill { background: linear-gradient(90deg, #ff6b35, #ff4500); }
    .energy-fill { background: linear-gradient(90deg, #ffd23f, #ffed4e); }
    .mood-fill { background: linear-gradient(90deg, #8b5cf6, #a855f7); }
    .karma-fill { background: linear-gradient(90deg, #06ffa5, #00ff88); }
    
    .coin-display {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    
    .karma-display {

      margin-top: 8px;
    }
    
 
    
    .karma-display .coin-amount {
      color: #06ffa5;
    }
    
    .drug-effects-panel {
      position: fixed;
      top: 280px;
      right: 20px;
      background: rgba(139, 92, 246, 0.9);
      border: 2px solid #a855f7;
      border-radius: 12px;
      padding: 12px;
      color: #fff;
      font-size: 0.9em;
      min-width: 200px;
      display: none;
    }
    
    .drug-effect-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      padding: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
    }
    
    .drug-effect-item:last-child {
      margin-bottom: 0;
    }
    
    .drug-effect-icon {
      font-size: 1.2em;
      margin-right: 8px;
    }
    
    .drug-effect-text {
      flex-grow: 1;
    }
    
    .gift-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 10px;
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .gift-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }
    
    .gift-item:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #ffd23f;
      transform: scale(1.05);
    }
    
    .gift-emoji {
      font-size: 2em;
      margin-bottom: 4px;
    }
    
    .gift-quantity {
      font-size: 0.8em;
      color: #ffd23f;
      font-weight: bold;
    }
    
    .gift-rewards {
      font-size: 0.7em;
      color: #06ffa5;
      text-align: center;
      margin-top: 2px;
    }
    
    .drug-effect-duration {
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .collection-feedback {
      position: relative;
      background: transparent;
      color: #fff;
      padding: 4px 8px;
      font-size: 1.3em;
      font-weight: bold;
      pointer-events: none;
      animation: slideInFade 3s ease-out forwards;
      margin-bottom: 8px;
      transform: translate(-50%, 0);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      z-index: 2000;
    }
    
    @keyframes slideInFade {
      0% {
        opacity: 0;
        transform: translate(-50%, -30%);
      }
      10% {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
      90% {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -70%);
      }
    }
    
    .collection-feedback.karma {
      color: #06ffa5;
    }
    
    .collection-feedback.coin {
      color: #ffd700;
    }
    
    .collection-feedback.water {
      color: #00bfff;
    }
    
    .collection-feedback.food {
      color: #ffa500;
    }
    
    .collection-feedback.drug {
      color: #8a2be2;
    }
    
    .collection-feedback.inventory {
      color: #ff69b4;
    }
    
    .collection-feedback.energy {
      color: #ff4757;
    }
    
    .collection-feedback.thirst {
      color: #00bcd4;
    }
    
    .collection-feedback.hunger {
      color: #ff9800;
    }
    
    .collection-feedback.mood {
      color: #e91e63;
    }
    
    .collection-feedback.time-effect {
      color: #ffd700;
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 2px 2px 8px rgba(255, 215, 0, 0.8);
      animation: timeEffectPulse 1s ease-in-out infinite;
    }
    
    @keyframes timeEffectPulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 0.8;
      }
    }
    
    /* Day Announcement Styles */
    .day-announcement {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translate(-50%, 0);
      color: white;
      padding: 15px 30px;
      font-size: 1.3em;
      font-weight: bold;
      text-align: center;
      z-index: 2000;
      animation: announcementSlideIn 0.5s ease-out, announcementPulse 2s ease-in-out infinite;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      max-width: 90%;
      line-height: 1.3;
    }
    
    @keyframes announcementSlideIn {
      from {
        opacity: 0;
        transform: translate(-50%, -20px) scale(0.8);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
    }
    
    @keyframes announcementPulse {
      0%, 100% {
        transform: translate(-50%, 0) scale(1);
      }
      50% {
        transform: translate(-50%, 0) scale(1.05);
      }
    }
    
    .drug-countdown-overlay {
      position: fixed;
      top: 320px;
      right: 20px;
      background: rgba(138, 43, 226, 0.9);
      color: #fff;
      padding: 12px 20px;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: bold;
      z-index: 999;
      pointer-events: none;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Intro Screen Styles */
    .intro-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #ff6b35, #f7931e, #ffd23f, #06ffa5, #8b5cf6);
      background-size: 400% 400%;
      animation: gradientShift 8s ease infinite;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .intro-content {
      max-width: 800px;
      width: 90%;
      margin: 0 auto;
      text-align: center;
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      height: 100%;
    }
    
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    .intro-content {
      background: rgba(255, 255, 255, 0.95);
      padding: 40px;
      border-radius: 20px;
      max-width: 800px;
      height: 70vh;
      overflow-y: auto;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      border: 3px solid #ff6b35;
      margin: 50px auto;
    }
    
    .intro-content h1 {
      color: #ff6b35;
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .intro-text {
      text-align: left;
      line-height: 1.6;
      margin-bottom: 30px;
      color: #000000;
    }
    
    .intro-text p {
      margin: 10px 0;
      font-size: 1.1em;
      color: #000000;
    }
    
    .intro-section {
      background: rgba(255, 107, 53, 0.1);
      padding: 20px;
      margin: 20px 0;
      border-radius: 10px;
      border-left: 5px solid #ff6b35;
      color: #000000;
    }
    
    .intro-section h3 {
      color: #ff6b35;
      margin-top: 0;
      font-size: 1.3em;
    }
    
    .intro-section p {
      margin: 8px 0;
      color: #000000;
    }
    
    .story-section {
      background: rgba(139, 92, 246, 0.1);
      padding: 20px;
      margin: 20px 0;
      border-radius: 10px;
      border-left: 5px solid #8b5cf6;
      color: #000000;
    }
    
    .story-section h3 {
      color: #8b5cf6;
      margin-top: 0;
      font-size: 1.3em;
    }
    
    .story-section p {
      margin: 8px 0;
      color: #000000;
    }
    
    .story-scene {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .dialogue-box {
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #ff6b35;
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      color: #fff;
    }
    
    .dialogue-text {
      font-size: 1.1em;
      line-height: 1.6;
      margin-bottom: 20px;
    }
    
    .dialogue-text p {
      margin: 10px 0;
      color: #fff;
    }
    
    .dialogue-btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 25px;
      font-size: 1.1em;
      font-weight: bold;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(255, 107, 53, 0.4);
    }
    
    .dialogue-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 107, 53, 0.6);
      background: linear-gradient(45deg, #f7931e, #ffd23f);
    }
    
    .choice-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }
    
    .choice-btn {
      background: #1c1c28;
      color: #eae9ff;
      border: 2px solid #8b5cf6;
      padding: 15px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s ease;
      text-align: left;
    }
    
    .choice-btn:hover {
      background: #232334;
      border-color: #a855f7;
      transform: translateX(5px);
    }
    
    .start-btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.3em;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 107, 53, 0.6);
      background: linear-gradient(45deg, #f7931e, #ffd23f);
    }
    
    .coin-icon {
      font-size: 1.2em;
    }
    
    .coin-label {
      font-size: 0.9em;
      color: #ffd23f;
      font-weight: bold;
      flex-grow: 1;
    }
    
    .coin-amount {
      color: #ffd700;
      font-weight: bold;
      font-size: 1.1em;
    }
    
    .actions-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #ff6b35;
      max-width: 300px;
      z-index: 100;
    }
    
    .action-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .action-btn {
      background: #1c1c28;
      color: #eae9ff;
      border: 1px solid #2a2a3d;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
      min-height: 44px;
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .action-btn:hover {
      background: #232334;
      border-color: #ff6b35;
    }
    
    .action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .top-info-panel {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border-radius: 10px;
      border: 2px solid #ff6b35;
      z-index: 100;
      text-align: center;
    }
    
    .time-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    
    .time-display {
      color: #ffd23f;
      font-size: 1.1em;
      font-weight: bold;
      margin: 0;
    }
    
    .version-display {
      position: fixed;
      bottom: 5px;
      right: 5px;
      color: #888;
      font-size: 0.7em;
      font-weight: normal;
      opacity: 0.7;
      z-index: 1000;
    }
    
    .pause-btn {
      background: rgba(255, 107, 53, 0.8);
      border: 2px solid #ff6b35;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    
    .pause-icon {
      display: flex;
      gap: 2px;
      align-items: center;
      justify-content: center;
    }
    
    .pause-bar {
      width: 3px;
      height: 12px;
      background: white;
      border-radius: 1px;
    }
    
    .pause-btn:hover {
      background: #ff6b35;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
    }
    
    .pause-btn.paused {
      background: rgba(255, 0, 0, 0.8);
      border-color: #ff0000;
    }
    
    .pause-btn.paused:hover {
      background: #ff0000;
    }
    
    .activities-display {
      color: #ffd23f;
      font-size: 0.9em;
      line-height: 1.3;
    }
    
    .activities-display p {
      margin: 2px 0;
      font-size: 0.85em;
    }
    
    .inventory-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      border: 2px solid #8b5cf6;
      min-width: 150px;
      z-index: 100;
    }
    
    .inventory-title {
      color: #8b5cf6;
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    
    .inventory-item {
      background: rgba(139, 92, 246, 0.2);
      padding: 3px 8px;
      margin: 2px 0;
      border-radius: 12px;
      font-size: 0.8em;
      border: 1px solid #8b5cf6;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inventory-item:hover {
      background: rgba(139, 92, 246, 0.4);
      border-color: #a855f7;
      transform: scale(1.05);
    }
    
    .inventory-item .quantity {
      background: rgba(255, 255, 255, 0.3);
      padding: 1px 6px;
      border-radius: 10px;
      font-size: 0.7em;
      font-weight: bold;
      min-width: 16px;
      text-align: center;
    }
    
    .encounter-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      padding: 20px;
      border-radius: 15px;
      border: 3px solid #ff6b35;
      max-width: 500px;
      z-index: 1000;
      text-align: center;
    }
    
    .stat-changes {
      font-size: 0.9em;
      margin: 10px 0;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffd700;
      font-weight: bold;
    }
    
    .encounter-text {
      color: #eae9ff;
      margin-bottom: 15px;
      font-size: 1.1em;
      line-height: 1.4;
    }
    
    .encounter-choices {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .choice-btn {
      background: #1c1c28;
      color: #eae9ff;
      border: 1px solid #2a2a3d;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s ease;
    }
    
    .choice-btn:hover {
      background: #232334;
      border-color: #ff6b35;
    }
    
    
    @keyframes pulse {
      0% { box-shadow: 0 0 20px rgba(255, 107, 53, 0.4); }
      50% { box-shadow: 0 0 30px rgba(255, 107, 53, 0.8); }
      100% { box-shadow: 0 0 20px rgba(255, 107, 53, 0.4); }
    }
    
    canvas {
      animation: pulse 2s infinite;
    }
    
    /* Story Mode Styles */
    .story-scene {
      display: none;
      max-width: 800px;
      text-align: center;
    }
    
    .dialogue-box {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #ffd700;
      border-radius: 10px;
      padding: 20px;
      margin: 20px auto;
      color: #fff;
      text-align: center;
    }
    
    .dialogue-text {
      font-size: 16px;
      line-height: 1.6;
      margin-bottom: 20px;
      text-align: left;
    }
    
    .dialogue-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }
    
    .dialogue-btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 0;
      display: inline-block;
    }
    
    .dialogue-btn.skip-btn {
      background: linear-gradient(45deg, #666, #888);
      font-size: 14px;
      padding: 10px 20px;
    }
    
    .dialogue-btn:hover {
      background: linear-gradient(45deg, #f7931e, #ff6b35);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.6);
    }
    
    .choice-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }
    
    .choice-btn {
      background: #1c1c28;
      color: #eae9ff;
      border: 1px solid #2a2a3d;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s ease;
    }
    
    .choice-btn:hover {
      background: #232334;
      border-color: #ff6b35;
    }
  </style>
</head>
<body>
  
  <div class="top-info-panel">
      <div class="version-display">v2069.27</div>
    <div class="time-controls">
      <div class="time-display" id="time-display">Day 1 • 08:00</div>
        <button class="pause-btn" id="pause-btn">
          <div class="pause-icon">
            <div class="pause-bar"></div>
            <div class="pause-bar"></div>
          </div>
        </button>
    </div>
    <div class="activities-display" id="activities-display">
      <p>Welcome to Burning Man! The playa is starting to fill up...</p>
    </div>
  </div>
  
  <div class="inventory-panel">
    <div class="inventory-title">🎒 Inventory</div>
    <div id="inventory-list">
      <!-- Inventory starts empty -->
    </div>
  </div>
  
  <div class="drug-effects-panel" id="drug-effects-panel">
    <div style="font-weight: bold; margin-bottom: 8px; color: #ffd700;">Active Effects</div>
    <div id="drug-effects-list">
      <!-- Drug effects will be populated here -->
    </div>
  </div>
  
  <div class="drug-countdown-overlay" id="drug-countdown-overlay" style="display: none;">
    <div id="countdown-text">Drug Effects: 10s</div>
  </div>
  
  <!-- Intro Screen (shown when exiting camp) -->
  <div id="intro-screen" class="intro-screen" style="display: none;">
    <div class="intro-content">
      <h1>🏜️ Welcome to the Playa! 🏜️ 🐾</h1>
      <div class="intro-text">
        <p><strong>You've made it through the gate! Now you're a wombat exploring the playa!</strong></p>
        <p>Your goal is to collect the most <strong>Wombat Coins</strong> and <strong>Karma</strong> during your 10-day Burning Man adventure.</p>
        
        <div class="intro-section">
          <h3>🎮 How to Play:</h3>
          <p>• Use <strong>Arrow Keys</strong> to move around</p>
          <p>• Press <strong>Space</strong> to get on/off bikes</p>
          <p>• Press any key to wake up from naps</p>
          <p>• Collect coins, water, food, and other items scattered across the playa</p>
          <p>• Pick up MOOP (trash) for karma points</p>
          <p>• Find art cars and bikes for faster transportation</p>
          <p>• Visit special locations like dance floors, art installations, and orgy domes</p>
          <p>• Use items from your inventory or give them as gifts</p>
          <p>• <strong>Keep your stat bars (Energy, Thirst, Hunger, Mood) high for top speed!</strong></p>
        </div>
        
        <div class="intro-section">
          <h3>🔥 The Timeline:</h3>
          <p>• <strong>Day 7 (Saturday):</strong> The Man burns!</p>
          <p>• <strong>Day 8 (Sunday):</strong> The Temple burns! Everything starts disappearing!</p>
          <p>• <strong>Day 11:</strong> The game ends!</p>
          <p>The playa starts empty but fills up as time goes on!</p>
        </div>
        
        <div class="intro-section">
          <h3>💊 Special Items:</h3>
          <p>• <strong>Drugs:</strong> Give speed boosts or slow you down, some cause hallucinations</p>
          <p>• <strong>Art Cars:</strong> Large vehicles you can ride around on</p>
          <p>• <strong>Bikes:</strong> Give you a 1.5x speed boost</p>
          <p>• <strong>MOOP:</strong> Trash items that give karma when collected</p>
        </div>
      </div>
      <button id="start-story-btn" class="start-btn">Enter the Playa! 🏜️</button>
    </div>
  </div>

  <!-- Story Mode Screen (starts first) -->
  <div id="story-screen" class="intro-screen">
    <div class="intro-content">
      <h1>🚐 The Burner Journey Begins 🚐</h1>
      
      <!-- Intro Banter Scene -->
      <div id="intro-banter" class="story-scene">
        <div class="dialogue-box">
          <div class="dialogue-text">
            <p><em>[Dusty RV interior, engine rattling. You're riding with a crew of fellow burners.]</em></p>
          </div>
          <div class="dialogue-buttons">
            <button class="dialogue-btn" onclick="nextDialogue()">Continue</button>
            <button class="dialogue-btn skip-btn" onclick="skipIntro()">Skip Intro</button>
          </div>
        </div>
      </div>
      
      <!-- The Line Scene -->
      <div id="the-line" class="story-scene" style="display: none;">
        <div class="dialogue-box">
          <div class="dialogue-text">
            <p><em>[The RV stops. Hours pass. Taillights stretch forever into the desert night.]</em></p>
          </div>
          <button class="dialogue-btn" onclick="nextDialogue()">Continue</button>
        </div>
      </div>
      
      <!-- Gate Ritual Scene -->
      <div id="gate-ritual" class="story-scene" style="display: none;">
        <div class="dialogue-box">
          <div class="dialogue-text">
            <p><strong>Gatekeeper (in neon fur):</strong> "Welcome home. Step outside. Do you know what time it is?"</p>
            <p><em>It's time for the dust angel ritual - a classic Burning Man tradition!</em></p>
          </div>
          <div class="choice-buttons">
            <button class="choice-btn" onclick="makeChoice(1)">Play along (drop and make a dust angel)</button>
            <button class="choice-btn" onclick="makeChoice(2)">Complain about the line</button>
            <button class="choice-btn" onclick="makeChoice(3)">Overdo it (flop dramatically, roll in the dust)</button>
          </div>
        </div>
      </div>
      
      <!-- Gate Results -->
      <div id="gate-results" class="story-scene" style="display: none;">
        <div class="dialogue-box">
          <div class="dialogue-text" id="gate-result-text">
            <!-- Results will be populated here -->
          </div>
          <button class="dialogue-btn" onclick="enterPlaya()">Enter the Playa! 🏜️</button>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="game-container" style="display: none;">
    <h1>🐾 Wombat Quest</h1>
    <canvas id="game" width="600" height="400"></canvas>
    <p class="controls">Use Arrow Keys to move • Space to get on/off bikes • Press any key to wake up from naps</p>
  </div>
  
  <div class="actions-panel">
    <div class="action-grid">
      <button class="action-btn" data-action="explore">Explore</button>
      <button class="action-btn" data-action="gift">Give Gift [G]</button>
      <button class="action-btn" data-action="rest">Rest (nap) [R]</button>
      <button class="action-btn" data-action="help">Help Stranger</button>
      <button class="action-btn" data-action="battle">Silly Battle</button>
      <button class="action-btn" data-action="meditate">Meditate</button>
    </div>
    <div class="action-grid" id="transport-actions" style="display: none;">
      <button class="action-btn" id="board-btn" data-action="board">Board Vehicle</button>
      <button class="action-btn" id="dismount-btn" data-action="dismount">Dismount Vehicle</button>
    </div>
    <div class="action-grid" id="location-actions" style="display: none;">
      <button class="action-btn" id="location-action-btn" data-action="">Location Action</button>
    </div>
  </div>
  
  <div class="stats-panel">
    <div class="stat-bar">
      <div class="stat-label">Thirst</div>
      <div class="stat-progress">
        <div class="stat-fill thirst-fill" id="thirst-bar"></div>
      </div>
      <div class="stat-value" id="thirst-value">100</div>
    </div>
    <div class="stat-bar">
      <div class="stat-label">Hunger</div>
      <div class="stat-progress">
        <div class="stat-fill hunger-fill" id="hunger-bar"></div>
      </div>
      <div class="stat-value" id="hunger-value">100</div>
    </div>
    <div class="stat-bar">
      <div class="stat-label">Energy</div>
      <div class="stat-progress">
        <div class="stat-fill energy-fill" id="energy-bar"></div>
      </div>
      <div class="stat-value" id="energy-value">100</div>
    </div>
    <div class="stat-bar">
      <div class="stat-label">Mood</div>
      <div class="stat-progress">
        <div class="stat-fill mood-fill" id="mood-bar"></div>
      </div>
      <div class="stat-value" id="mood-value">100</div>
    </div>
    <div class="coin-display">
      <div class="coin-label">Coins</div>
      <div class="coin-amount" id="coin-amount">0</div>
    </div>
    <div class="coin-display karma-display">
      <div class="coin-label">Karma</div>
      <div class="coin-amount" id="karma-amount">0</div>
    </div>
    <div class="coin-display">
      <div class="coin-label">Speed</div>
      <div class="coin-amount" id="speed-display">1.0x</div>
    </div>
    <div class="coin-display">
      <div class="coin-label">Time</div>
      <div class="coin-amount" id="time-perception-display">1.0x</div>
    </div>
    <div class="coin-display">
      <div class="coin-label">Stats</div>
      <div class="coin-amount" id="stats-speed-display">1.0x</div>
    </div>
  </div>

  <script type="module">
    // Import the new modular game system
    import { WombatQuestGame } from './src/index.js';
    
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    
    // Initialize the new game system
    let game = new WombatQuestGame(canvas);
    
    // Set canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // The new game system handles player positioning internally
      // No need to manually update player.screenX/Y or camera.x/y
    }
    
    window.addEventListener('resize', resizeCanvas);

    // Camera system - keeps player centered
    const camera = {
      x: 0,
      y: 0
    };
    
    // Player world position (not screen position)
    const player = {
      worldX: 0, worldY: 0, // Player's position in the world
      screenX: 0, screenY: 0, // Player's position on screen (always center)
      w: 32, h: 32,
      speed: 6,
      color: "#ff6b35",
      stats: {
        coin: 0,
        karma: 0,
        hunger: 70,
        thirst: 70,
        energy: 70,
        mood: 70
      },
      inventory: { 
        'Water': 3,
        'Grilled Cheese': 1,
        'Energy Bar': 1,
        'Gas Can': 0
      },
      flags: { storm: false, goggles: false },
      time: { day: 1, hour: 8, minute: 0 },
      inCamp: false,  // Track if player is in camp
      hasSeenCampDialogue: false,  // Track if player has seen the camp welcome dialogue
      drugEffects: {
        activeDrugs: [],  // Array of active drugs with their effects and durations
        timeMultiplier: 1.0,
        timeStopDuration: 0,
        timeAccumulator: 0,
        whipitsCount: 0  // Track Whip Its usage for vinetting effect
      },
      tripStats: {
        totalDrugsConsumed: 0,
        drugsTried: new Set(),
        timeHigh: 0,  // Frames spent under drug effects
        totalPlayTime: 0,  // Total frames played
        gameStartTime: Date.now(),
        totalDistance: 0,  // Total distance traveled in pixels
        lastX: 0,
        lastY: 0,
        walkingTime: 0,  // Frames spent walking
        bikingTime: 0,   // Frames spent on bike
        artCarTime: 0,   // Frames spent on art car
        meditationCount: 0,  // Number of meditation sessions
        highMoodTime: 0,     // Frames spent with mood > 80
        lowMoodTime: 0,      // Frames spent with mood < 20
        wellRestedTime: 0,   // Frames spent with energy > 80
        exhaustedTime: 0,    // Frames spent with energy < 20
        fastTime: 0,         // Frames spent with high speed multiplier
        slowTime: 0          // Frames spent with low speed multiplier
      },
      sleeping: false,
      sleepStartTime: 0,
      cooldowns: {
        dance: 0,
        climb: 0,
        orgy: 0,
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0,
        homeSpawn: 0  // Timer for home camp item spawning (15 seconds)
      },
      lastActionTimes: {
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0
      }
    };
    
    // Game state
    const gameState = {
      ended: false,
      finalScore: { coins: 0, karma: 0 }
    };
    
    // Generate trip report and archetype
    function generateTripReport() {
      const totalPlayTimeHours = Math.floor(player.tripStats.totalPlayTime / 3600);
      const timeHighPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.timeHigh / player.tripStats.totalPlayTime) * 100) : 0;
      const drugsTriedCount = player.tripStats.drugsTried.size;
      const totalDistanceMiles = Math.round(player.tripStats.totalDistance / 100); // Rough conversion: 100 pixels = 1 mile
      
      // Determine archetype based on stats
      let archetype = '';
      let description = '';
      
      // Wealth-based archetypes (300+ thresholds)
      if (player.stats.coin >= 300 && player.stats.karma >= 300) {
        archetype = 'Playa Legend';
        description = 'You mastered both the material and spiritual aspects of Burning Man!';
      } else if (player.stats.coin >= 300) {
        archetype = 'Playa Baller';
        description = 'You came to party with the best of them and found all the good stuff!';
      } else if (player.stats.karma >= 300) {
        archetype = 'Karma King/Queen';
        description = 'The playa loves you back - you gave more than you took!';
      } else if (player.stats.coin < 100 && player.stats.karma < 100) {
        archetype = 'Dust Survivor';
        description = 'You made it through the dust with nothing but love and determination!';
      } else {
        archetype = 'The Wanderer';
        description = 'You experienced it all and found your own path through the playa!';
      }
      
      // Distance-based archetypes (highest priority)
      if (totalDistanceMiles >= 100) {
        archetype = 'Playa Marathoner';
        description = 'You covered every inch of the playa and explored the entire city!';
      } else if (totalDistanceMiles >= 50) {
        archetype = 'Wandering Soul';
        description = 'You were a true nomad, always on the move across the playa!';
      } else if (totalDistanceMiles <= 10) {
        archetype = 'Homebody';
        description = 'You found your spot and made it home - sometimes the best burn is staying put!';
      }
      // Drug experience modifiers (if no distance archetype)
      else if (drugsTriedCount >= 8) {
        archetype = 'Psychonaut Explorer';
        description = 'You\'ve seen beyond the veil and explored every dimension of consciousness!';
      } else if (timeHighPercentage >= 50) {
        archetype = 'Party Animal';
        description = 'You were living in the moment and fully immersed in the experience!';
      } else if (timeHighPercentage <= 10) {
        archetype = 'Sober Scout';
        description = 'You kept your wits about you and saw Burning Man with clear eyes!';
      }
      
      // Calculate percentages for new stats
      const highMoodPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.highMoodTime / player.tripStats.totalPlayTime) * 100) : 0;
      const lowMoodPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.lowMoodTime / player.tripStats.totalPlayTime) * 100) : 0;
      const wellRestedPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.wellRestedTime / player.tripStats.totalPlayTime) * 100) : 0;
      const exhaustedPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.exhaustedTime / player.tripStats.totalPlayTime) * 100) : 0;
      const fastPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.fastTime / player.tripStats.totalPlayTime) * 100) : 0;
      const slowPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.slowTime / player.tripStats.totalPlayTime) * 100) : 0;
      
      // Movement percentages
      const walkingPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.walkingTime / player.tripStats.totalPlayTime) * 100) : 0;
      const bikingPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.bikingTime / player.tripStats.totalPlayTime) * 100) : 0;
      const artCarPercentage = player.tripStats.totalPlayTime > 0 ? 
        Math.round((player.tripStats.artCarTime / player.tripStats.totalPlayTime) * 100) : 0;
      
      // Special achievements
      let achievements = [];
      if (drugsTriedCount >= 6) achievements.push('🌈 Rainbow Warrior');
      if (player.stats.coin >= 1000) achievements.push('💎 Diamond Hands');
      if (player.stats.karma >= 500) achievements.push('❤️ Heart of Gold');
      if (player.time.day >= 10) achievements.push('🌪️ Dust Storm Survivor');
      if (timeHighPercentage >= 90) achievements.push('🎪 Party Legend');
      if (totalDistanceMiles >= 100) achievements.push('🏃 Marathoner');
      if (player.tripStats.meditationCount >= 5) achievements.push('🧘 Meditator');
      
      // Mood-based achievements
      if (highMoodPercentage >= 50) achievements.push('😊 Sunshine Soul');
      if (lowMoodPercentage >= 30) achievements.push('😔 Moody Blues');
      
      // Rest-based achievements
      if (wellRestedPercentage >= 60) achievements.push('😴 Well Rested');
      if (exhaustedPercentage >= 40) achievements.push('😵 Exhausted Explorer');
      
      // Speed-based achievements
      if (fastPercentage >= 40) achievements.push('⚡ Speed Demon');
      if (slowPercentage >= 50) achievements.push('🐌 Slow & Steady');
      
      // Movement-based achievements
      if (walkingPercentage >= 70) achievements.push('🚶 Walking Warrior');
      if (bikingPercentage >= 50) achievements.push('🚲 Cycle Master');
      if (artCarPercentage >= 30) achievements.push('🎨 Art Car Connoisseur');
      
      return {
        archetype,
        description,
        totalPlayTimeHours,
        timeHighPercentage,
        totalDrugsConsumed: player.tripStats.totalDrugsConsumed,
        drugsTriedCount,
        achievements,
        finalCoins: player.stats.coin,
        finalKarma: player.stats.karma,
        totalDistanceMiles,
        highMoodPercentage,
        lowMoodPercentage,
        wellRestedPercentage,
        exhaustedPercentage,
        fastPercentage,
        slowPercentage,
        walkingPercentage,
        bikingPercentage,
        artCarPercentage,
        meditationCount: player.tripStats.meditationCount
      };
    }
    
    // Game ending functions
    function endGameFunction() {
      if (gameState.ended) return; // Prevent multiple endings
      
      gameState.ended = true;
      gameState.finalScore = { 
        coins: player.stats.coin, 
        karma: player.stats.karma 
      };
      
      // Generate trip report
      const tripReport = generateTripReport();
      
      // Create game over screen
      const gameOverScreen = document.createElement('div');
      gameOverScreen.id = 'game-over-screen';
      gameOverScreen.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        color: white;
        font-family: Arial, sans-serif;
      `;
      
      gameOverScreen.innerHTML = `
        <div style="text-align: center; max-width: 700px; padding: 40px;">
          <h1 style="color: #ff6b35; font-size: 2.5em; margin-bottom: 20px;">🔥 BURNING MAN 2069 - TRIP REPORT 🔥</h1>
          
          <div style="background: rgba(255, 255, 255, 0.1); padding: 30px; border-radius: 15px; margin: 20px 0;">
            <h2 style="color: #ffd23f; margin-bottom: 20px;">🏕️ Your Burn Stats:</h2>
            <div style="font-size: 1.2em; margin: 10px 0; line-height: 1.6;">
              <div style="color: #ffd23f;">💰 Final Wealth: ${tripReport.finalCoins} coins, ${tripReport.finalKarma} karma</div>
              <div style="color: #4ecdc4;">💊 Drugs Consumed: ${tripReport.totalDrugsConsumed} total</div>
              <div style="color: #ff6b9d;">🧠 Time High: ${tripReport.timeHighPercentage}% of your burn</div>
              <div style="color: #96ceb4;">🌈 Drug Variety: ${tripReport.drugsTriedCount} different types</div>
              <div style="color: #feca57;">⏰ Total Time: ${tripReport.totalPlayTimeHours} hours</div>
            </div>
          </div>
          
          <div style="background: rgba(138, 43, 226, 0.2); padding: 30px; border-radius: 15px; margin: 20px 0; border: 2px solid #a855f7;">
            <h2 style="color: #a855f7; margin-bottom: 15px;">🎭 Your Archetype:</h2>
            <div style="font-size: 1.8em; color: #ffd700; margin-bottom: 10px; font-weight: bold;">${tripReport.archetype}</div>
            <div style="font-size: 1.1em; color: #fff; font-style: italic;">${tripReport.description}</div>
          </div>
          
          ${tripReport.achievements.length > 0 ? `
          <div style="background: rgba(255, 215, 0, 0.1); padding: 25px; border-radius: 15px; margin: 20px 0;">
            <h3 style="color: #ffd700; margin-bottom: 15px;">🏆 Special Achievements:</h3>
            <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">
              ${tripReport.achievements.map(achievement => `<span style="background: rgba(255, 215, 0, 0.2); padding: 8px 12px; border-radius: 20px; font-size: 0.9em;">${achievement}</span>`).join('')}
            </div>
          </div>
          ` : ''}
          
          <div style="margin-top: 30px; font-size: 1.1em; color: #ccc;">
            <p>🏜️ You survived ${player.time.day - 1} days on the playa!</p>
              <p>The Man and Temple have burned, and the temporary city has returned to dust.</p>
              <p>Thank you for being part of the Burning Man experience!</p>
            </div>
          
          <button id="restart-btn" style="
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
          ">Play Again 🔥</button>
        </div>
      `;
      
      document.body.appendChild(gameOverScreen);
      
      // Create confetti explosion at screen center
      setTimeout(() => {
        createConfettiExplosion(window.innerWidth / 2, window.innerHeight / 2, 100);
        // Create additional smaller explosions
        setTimeout(() => createConfettiExplosion(window.innerWidth / 2 - 200, window.innerHeight / 2, 50), 500);
        setTimeout(() => createConfettiExplosion(window.innerWidth / 2 + 200, window.innerHeight / 2, 50), 1000);
        setTimeout(() => createConfettiExplosion(window.innerWidth / 2, window.innerHeight / 2 - 100, 50), 1500);
      }, 100);
      
      // Add restart functionality
      const restartBtn = document.getElementById('restart-btn');
      restartBtn.addEventListener('click', restartGame);
    }
    
    function restartGame() {
      // Remove game over screen
      const gameOverScreen = document.getElementById('game-over-screen');
      if (gameOverScreen) {
        gameOverScreen.remove();
      }
      
      // Reset game state
      gameState.ended = false;
      gameState.finalScore = { coins: 0, karma: 0 };
      
      // Clear confetti from previous game
      confetti = [];
      mollyHearts = [];
      
      // Reset player - spawn will be set after home base is generated
      player.worldX = 0; // Temporary, will be updated after home base generation
      player.worldY = 0; // Temporary, will be updated after home base generation
      player.stats.coin = 0;
      player.stats.karma = 0;
      player.stats.hunger = 70;
      player.stats.thirst = 70;
      player.stats.energy = 70;
      player.stats.mood = 70;
      player.inventory = { 
        'Water': 3,
        'Grilled Cheese': 1,
        'Energy Bar': 1,
        'Gas Can': 0
      };
      player.time = { day: 1, hour: 8, minute: 0 };
      player.drugEffects.activeDrugs = [];
      player.drugEffects.timeMultiplier = 1.0;
      player.drugEffects.timeStopDuration = 0;
      player.drugEffects.timeAccumulator = 0;
      player.drugEffects.whipitsCount = 0;
      player.tripStats.totalDrugsConsumed = 0;
      player.tripStats.drugsTried = new Set();
      player.tripStats.timeHigh = 0;
      player.tripStats.totalPlayTime = 0;
      player.tripStats.gameStartTime = Date.now();
      player.tripStats.totalDistance = 0;
      player.tripStats.lastX = player.worldX;
      player.tripStats.lastY = player.worldY;
      player.tripStats.walkingTime = 0;
      player.tripStats.bikingTime = 0;
      player.tripStats.artCarTime = 0;
      player.tripStats.meditationCount = 0;
      player.tripStats.highMoodTime = 0;
      player.tripStats.lowMoodTime = 0;
      player.tripStats.wellRestedTime = 0;
      player.tripStats.exhaustedTime = 0;
      player.tripStats.fastTime = 0;
      player.tripStats.slowTime = 0;
      player.sleeping = false;
      player.sleepStartTime = 0;
      player.cooldowns = {
        dance: 0,
        climb: 0,
        orgy: 0,
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0,
        homeSpawn: 0
      };
      player.lastActionTimes = {
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0,
        climb: 0
      };
      
      // Reset riding states
      ridingArtCar = null;
      ridingBike = null;
      lastExitTime = 0;
      
      // Clear all world content
      decorations.length = 0;
      coins.length = 0;
      waterBottles.length = 0;
      snacks.length = 0;
      bikes.length = 0;
      artCars.length = 0;
      moop.length = 0;
      drugs.length = 0;
      danceFloors.length = 0;
      artInstallations.length = 0;
      orgyDomes.length = 0;
      homeCamps.length = 0;
      centerCamps.length = 0;
      fuelStations.length = 0;
      npcs.length = 0;
      gasolineTanks.length = 0;
      
      // Reset world generation
      generatedChunks.clear();
      worldPopulationMultiplier = 0.1;
      lastAnnouncedDay = 0;
      lastTimeUpdate = Date.now();
      
      // Reset camera
      camera.x = 0;
      camera.y = 0;
      
      // Reset Man and Temple structures
      manStructure.burned = false;
      manStructure.limbs = 0;
      manStructure.constructionProgress = 0;
      
      templeStructure.burned = false;
      templeStructure.constructionProgress = 0;
      
      // Update displays
      updateStatsDisplay();
      updateTimeDisplay();
      updateInventoryDisplay();
      updateDrugEffectsDisplay();
      updateTransportButtons();
      
      // Generate initial world content
      generateWorldContent();
      
      // Update displays to show starting items
      updateInventoryDisplay();
      updateStatsDisplay();
      
      // Restart the game loop
      loop();
    }

    const keys = {};

    // Add some Burning Man themed decorations and collectibles
    const decorations = [];
    
    // Add collectible coins
    const coins = [];
    
    // Add collectible water bottles and snacks
    const waterBottles = [];
    const snacks = [];
    
    // Art cars that wander around
    const artCars = [];
    
    // Bikes that can be ridden
    const bikes = [];
    
    // Gasoline tanks for mutant vehicles
    const gasolineTanks = [];
    
    // NPCs (survivors in the wasteland)
    const npcs = [];
    
    // MOOP (Matter Out Of Place) items for karma
    const moop = [];
    
    // Drugs with various effects
    const drugs = [];
    
    // Special locations for actions
    const danceFloors = [];
    const artInstallations = [];
    const orgyDomes = [];
    const homeCamps = [];
    const centerCamps = [];
    const fuelStations = [];
    
    // Handle items disappearing after Burning Man
    function handlePostBurnDisappearing() {
      const currentDay = player.time.day;
      
      // Only run disappearing logic once per day
      if (currentDay === lastDisappearingDay) {
        return;
      }
      
      // Day 8-10: Things start disappearing gradually (Sunday onwards)
      if (currentDay >= 8 && currentDay <= 10) {
        lastDisappearingDay = currentDay;
        const disappearingChance = (currentDay - 7) * 0.1; // 10% on day 8, 20% on day 9, 30% on day 10
        
        // Count items before removal for feedback
        const coinsBefore = coins.length;
        const waterBefore = waterBottles.length;
        const snacksBefore = snacks.length;
        const moopBefore = moop.length;
        const drugsBefore = drugs.length;
        const bikesBefore = bikes.length;
        
        // Remove items more efficiently (mutate in place)
        for (let i = coins.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            coins.splice(i, 1);
          }
        }
        
        for (let i = waterBottles.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            waterBottles.splice(i, 1);
          }
        }
        
        for (let i = snacks.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            snacks.splice(i, 1);
          }
        }
        
        for (let i = moop.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            moop.splice(i, 1);
          }
        }
        
        for (let i = drugs.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            drugs.splice(i, 1);
          }
        }
        
        for (let i = bikes.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            bikes.splice(i, 1);
          }
        }
        
        // Remove special locations
        for (let i = danceFloors.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            danceFloors.splice(i, 1);
          }
        }
        
        for (let i = artInstallations.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            artInstallations.splice(i, 1);
          }
        }
        
        for (let i = orgyDomes.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            orgyDomes.splice(i, 1);
          }
        }
        
        for (let i = homeCamps.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            homeCamps.splice(i, 1);
          }
        }
        
        for (let i = centerCamps.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            centerCamps.splice(i, 1);
          }
        }
        
        for (let i = fuelStations.length - 1; i >= 0; i--) {
          if (Math.random() <= disappearingChance) {
            fuelStations.splice(i, 1);
          }
        }
        
        // Show feedback for disappearing items
        const totalDisappeared = (coinsBefore - coins.length) + (waterBefore - waterBottles.length) + 
                                (snacksBefore - snacks.length) + (moopBefore - moop.length) + 
                                (drugsBefore - drugs.length) + (bikesBefore - bikes.length);
        
        if (totalDisappeared > 0 && Math.random() < 0.3) { // 30% chance to show feedback
          showCollectionFeedback(`${totalDisappeared} items disappeared as people leave...`, 'mood', 0);
        }
      }
      
      // Day 11+: Everything disappears completely
      if (currentDay >= 11) {
        const hadItems = coins.length > 0 || waterBottles.length > 0 || snacks.length > 0 || 
                        moop.length > 0 || drugs.length > 0 || bikes.length > 0 || artCars.length > 0;
        
        // Clear arrays in place to avoid reassigning consts
        coins.length = 0;
        waterBottles.length = 0;
        snacks.length = 0;
        moop.length = 0;
        drugs.length = 0;
        bikes.length = 0;
        danceFloors.length = 0;
        artInstallations.length = 0;
        orgyDomes.length = 0;
        homeCamps.length = 0;
        centerCamps.length = 0;
        fuelStations.length = 0;
        
        // Art cars also leave
        artCars = [];
        
        // Show feedback if there were items to remove
        if (hadItems) {
          showCollectionFeedback('Everything has been packed away... The playa is empty.', 'mood', 0);
        }
      }
    }
    
    // Update Man and Temple construction progress
    function updateStructures() {
      const currentDay = player.time.day;
      
      // Update Man construction (grows limbs each day until day 8)
      if (currentDay <= MAN_BURN_DAY) {
        const targetLimbs = Math.min(currentDay, manStructure.maxLimbs);
        manStructure.limbs = targetLimbs;
        manStructure.constructionProgress = (targetLimbs / manStructure.maxLimbs) * 100;
      }
      
      // Man burns on day 8 (only once)
      if (currentDay === MAN_BURN_DAY && player.time.hour === 0 && !manStructure.burned) {
        manStructure.burned = true;
        console.log('🔥 THE MAN BURNS! 🔥');
      }
      
      // Update Temple construction (builds gradually from day 1 to day 10)
      if (currentDay <= TEMPLE_BURN_DAY) {
        templeStructure.constructionProgress = (currentDay / TEMPLE_BURN_DAY) * 100;
      }
      
      // Temple burns on day 10 (only once)
      if (currentDay === TEMPLE_BURN_DAY && player.time.hour === 0 && !templeStructure.burned) {
        templeStructure.burned = true;
        console.log('🔥 THE TEMPLE BURNS! 🔥');
      }
    }

    // Helper function to check if a position is within playa boundaries
    function isWithinBoundaries(x, y) {
      const distanceFromCenter = Math.sqrt(x * x + y * y);
      return distanceFromCenter <= PLAYA_RADIUS;
    }

    // Global item type definitions
    const foodTypes = [
      { name: 'Grilled Cheese', hunger: 25, color: '#FFD700', emoji: '🧀', type: 'food' },
      { name: 'Veggie Burger', hunger: 35, color: '#8B4513', emoji: '🍔', type: 'food' },
      { name: 'Fruit Salad', hunger: 20, color: '#FF69B4', emoji: '🥗', type: 'food' },
      { name: 'Energy Bar', hunger: 15, energy: 20, color: '#8B4513', emoji: '🍫', type: 'food' },
      { name: 'Pizza Slice', hunger: 30, color: '#FF6347', emoji: '🍕', type: 'food' },
      { name: 'Smoothie', hunger: 18, color: '#32CD32', emoji: '🥤', type: 'food' },
      { name: 'Popsicle', hunger: 8, color: '#FF1493', emoji: '🍭', type: 'food' },
      { name: 'Burrito', hunger: 28, color: '#8B4513', emoji: '🌯', type: 'food' },
      { name: 'Taco', hunger: 22, color: '#FF6347', emoji: '🌮', type: 'food' },
      { name: 'Ice Cream', hunger: 12, color: '#F0F8FF', emoji: '🍦', type: 'food' },
      { name: 'Pretzel', hunger: 18, color: '#D2691E', emoji: '🥨', type: 'food' },
      { name: 'Corn Dog', hunger: 25, color: '#CD853F', emoji: '🌭', type: 'food' },
      { name: 'Funnel Cake', hunger: 20, color: '#FFF8DC', emoji: '🍰', type: 'food' },
      { name: 'Nachos', hunger: 24, color: '#FFD700', emoji: '🧀', type: 'food' },
      { name: 'Cotton Candy', hunger: 5, color: '#FFB6C1', emoji: '🍬', type: 'food' }
    ];

    const waterTypes = [
      { name: 'Water Bottle', thirst: 30, color: '#00BFFF', emoji: '💧', type: 'water' },
      { name: 'Electrolyte Drink', thirst: 35, energy: 10, color: '#FFD700', emoji: '⚡', type: 'water' },
      { name: 'Coconut Water', thirst: 25, color: '#8B4513', emoji: '🥥', type: 'water' }
    ];

    const drugTypes = [
      { name: 'Caffeine', speedMultiplier: 1.5, duration: 3, emoji: '☕', type: 'drug' },
      { name: 'Energy Drink', speedMultiplier: 2.0, energy: 30, duration: 5, emoji: '⚡', type: 'drug' },
      { name: 'Molly', speedMultiplier: 1.8, mood: 25, energy: 20, duration: 8, specialEffects: 'molly', emoji: '💊', type: 'drug' },
      { name: 'Shrooms', speedMultiplier: 0.7, hallucinating: true, duration: 12, specialEffects: 'shrooms', emoji: '🍄', type: 'drug' },
      { name: 'Acid', speedMultiplier: 0.5, hallucinating: true, duration: 20, specialEffects: 'acid', emoji: '🌈', type: 'drug' },
      { name: 'Alcohol', speedMultiplier: 0.8, mood: 15, energy: -10, duration: 6, specialEffects: 'alcohol', emoji: '🍺', type: 'drug' },
      { name: 'DMT', speedMultiplier: 0.3, hallucinating: true, duration: 4, specialEffects: 'dmt', emoji: '👁️', type: 'drug' },
      { name: 'Salvia', speedMultiplier: 0.2, hallucinating: true, duration: 2, specialEffects: 'salvia', emoji: '🌀', type: 'drug' },
      { name: 'Whip Its', speedMultiplier: 1.0, timeMultiplier: 0, duration: 1, specialEffects: 'whipits', emoji: '💨', type: 'drug' }
    ];

    // Generate camp world content - small contained area with fence and exit
    function generateCampWorld() {
      
      // Clear existing content (but preserve playa world content)
      decorations.length = 0;
      coins.length = 0;
      waterBottles.length = 0;
      snacks.length = 0;
      bikes.length = 0;
      artCars.length = 0;
      moop.length = 0;
      drugs.length = 0;
      danceFloors.length = 0;
      artInstallations.length = 0;
      orgyDomes.length = 0;
      // DON'T clear homeCamps - this contains the player's home base in the playa world
      centerCamps.length = 0;
      fuelStations.length = 0;
      npcs.length = 0;
      gasolineTanks.length = 0;
      
      // Create a small camp area (about screen size) with thin borders
      decorations.push({
        x: -400, y: -300, w: 800, h: 4, type: 'fence', name: 'Camp Fence (North)',
        emoji: '🚧', color: '#ff6b35'
      });
      decorations.push({
        x: -400, y: 296, w: 800, h: 4, type: 'fence', name: 'Camp Fence (South)',
        emoji: '🚧', color: '#ff6b35'
      });
      decorations.push({
        x: -400, y: -300, w: 4, h: 600, type: 'fence', name: 'Camp Fence (West)',
        emoji: '🚧', color: '#ff6b35'
      });
      decorations.push({
        x: 396, y: -300, w: 4, h: 600, type: 'fence', name: 'Camp Fence (East)',
        emoji: '🚧', color: '#ff6b35'
      });
      
      // Add some camp decorations
      decorations.push({
        x: -200, y: -200, w: 60, h: 40, type: 'tent', name: 'Main Tent',
        emoji: '⛺', color: '#8B4513'
      });
      decorations.push({
        x: 100, y: -150, w: 40, h: 30, type: 'tent', name: 'Storage Tent',
        emoji: '⛺', color: '#654321'
      });
      decorations.push({
        x: -300, y: 50, w: 50, h: 50, type: 'kitchen', name: 'Camp Kitchen',
        emoji: '🍳', color: '#FFD700'
      });
      decorations.push({
        x: 200, y: 100, w: 40, h: 40, type: 'shade', name: 'Shade Structure',
        emoji: '🏕️', color: '#87CEEB'
      });
      
      // Add other wombats to the camp
      const wombatNames = ['Wally', 'Wendy', 'Winston', 'Willow', 'Wade', 'Wanda'];
      const wombatColors = ['#ff6b35', '#8b5cf6', '#06ffa5', '#ffd23f', '#ff4757', '#2ed573'];
      const wombatPositions = [
        { x: -150, y: -100 }, // Near main tent
        { x: 50, y: -80 },    // Near storage tent
        { x: -250, y: 80 },   // Near kitchen
        { x: 150, y: 120 },   // Near shade
        { x: -50, y: 200 },   // Center area
        { x: 250, y: -50 }    // East side
      ];
      
      wombatPositions.forEach((pos, index) => {
        if (index < wombatNames.length) {
          npcs.push({
            x: pos.x,
            y: pos.y,
            w: 32,
            h: 32,
            vx: (Math.random() - 0.5) * 2, // Random initial velocity
            vy: (Math.random() - 0.5) * 2,
            emoji: '', // No emoji - will be drawn as blocky wombat
            name: wombatNames[index],
            color: wombatColors[index],
            behavior: 'camp',
            behaviorTimer: Math.random() * 120 + 60, // Random timer for direction changes
            hasGasCan: false,
            gasCanFuel: 0,
            karmaReward: 0,
            chunkId: 'camp',
            isWombat: true // Flag to identify wombats
          });
        }
      });
      
      campWorldGenerated = true;
    }

    // Generate world content around player position
    function generateWorldContent() {
      if (currentWorld === 'camp') {
        if (!campWorldGenerated) {
          generateCampWorld();
        }
        return;
      }
      
      // Only generate playa world once
      if (playaWorldGenerated) {
        return;
      }
      
      playaWorldGenerated = true;
      
      // Generate center camp first (only once)
      generateCenterCamp();
      
      // Generate player home base (only once)
      generatePlayerHomeBase();
      
      const worldSize = 6000; // World extends 3000 pixels in each direction from center (doubled)
      const chunkSize = 400; // Generate content in 400x400 chunks
      
      // Generate content in a large area around the center (0,0) instead of around player position
      // This ensures the world is consistent regardless of where the player exits camp
      const centerChunkX = 0; // Center chunk
      const centerChunkY = 0; // Center chunk
      const generationRadius = 8; // Generate content in a 17x17 grid around center (8 chunks in each direction)
      
      // Generate content for a large area around the center
      for (let x = centerChunkX - generationRadius; x <= centerChunkX + generationRadius; x++) {
        for (let y = centerChunkY - generationRadius; y <= centerChunkY + generationRadius; y++) {
          const chunkId = `${x},${y}`;
          
          // Skip if already generated
          if (generatedChunks.has(chunkId)) continue;
          
          // Check if chunk is within playa boundaries
          const chunkStartX = x * chunkSize;
          const chunkStartY = y * chunkSize;
          const chunkCenterX = chunkStartX + chunkSize / 2;
          const chunkCenterY = chunkStartY + chunkSize / 2;
          const distanceFromCenter = Math.sqrt(chunkCenterX * chunkCenterX + chunkCenterY * chunkCenterY);
          
          // Skip chunks outside the playa - check if chunk corners are within boundary
          const chunkCornerDistance = Math.sqrt(
            Math.pow(Math.max(Math.abs(chunkStartX), Math.abs(chunkStartX + chunkSize)), 2) +
            Math.pow(Math.max(Math.abs(chunkStartY), Math.abs(chunkStartY + chunkSize)), 2)
          );
          
          // Skip chunks if any corner would be outside the boundary
          if (chunkCornerDistance > PLAYA_RADIUS) continue;
          
          generatedChunks.add(chunkId);
          
          // Generate content for this chunk
          
          // Generate decorations (scaled by population, 1/3 rate)
          const decorationCount = Math.floor((Math.random() * 3 + 1) * worldPopulationMultiplier / 3);
          for (let i = 0; i < decorationCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              decorations.push({
                x: x,
                y: y,
                w: Math.random() * 20 + 10,
                h: Math.random() * 20 + 10,
                color: ["#ffd23f", "#ff6b35", "#8b5cf6", "#06ffa5"][Math.floor(Math.random() * 4)],
                type: ["art", "temple", "camp"][Math.floor(Math.random() * 3)],
                chunkId: chunkId
              });
            }
          }
          
          // Generate coins (scaled by population, 1/3 rate)
          const coinCount = Math.floor((Math.random() * 20 + 13) * worldPopulationMultiplier / 3);
          for (let i = 0; i < coinCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              coins.push({
                x: x,
                y: y,
                w: 8, h: 8, collected: false, chunkId: chunkId
              });
            }
          }
          
          // Generate water bottles (scaled by population, minimum spawn rate)
          const waterCount = Math.floor((Math.random() * 5 + 3) * Math.max(worldPopulationMultiplier, 0.1));
          for (let i = 0; i < waterCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              waterBottles.push({
                x: x,
                y: y,
                w: 12, h: 16, collected: false, chunkId: chunkId
              });
            }
          }
          
          // Generate snacks (scaled by population) - different food types
          
          const snackCount = Math.floor((Math.random() * 4 + 2) * Math.max(worldPopulationMultiplier, 0.1)); // Minimum spawn rate
          for (let i = 0; i < snackCount; i++) {
            const foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              snacks.push({
                x: x,
                y: y,
                w: 16, h: 16, collected: false, chunkId: chunkId,
                name: foodType.name,
                hunger: foodType.hunger,
                color: foodType.color,
                emoji: foodType.emoji
              });
            }
          }
          
          // Generate art cars (scaled by population)
          if (Math.random() < 0.4 * worldPopulationMultiplier) { // Population-scaled chance (5x increase)
            
            // Different art car types with unique properties (50% smaller + tiny fast ones)
            const carTypes = [
              // Regular sized cars (50% smaller)
              { name: "Disco Bus", w: 400, h: 200, color: "#ff6b35", speed: 3.0, design: "bus" },
              { name: "Crystal Ship", w: 300, h: 250, color: "#8b5cf6", speed: 4.0, design: "ship" },
              { name: "Neon Whale", w: 500, h: 150, color: "#06ffa5", speed: 2.5, design: "whale" },
              { name: "Laser Cat", w: 250, h: 175, color: "#ffd23f", speed: 6.0, design: "cat" },
              { name: "Rainbow Dragon", w: 350, h: 225, color: "#ff4757", speed: 5.0, design: "dragon" },
              { name: "Cosmic Turtle", w: 450, h: 300, color: "#2ed573", speed: 2.0, design: "turtle" },
              { name: "Phoenix Express", w: 325, h: 190, color: "#ff6348", speed: 8.0, design: "phoenix" },
              { name: "Mystic Octopus", w: 275, h: 275, color: "#5f27cd", speed: 4.5, design: "octopus" },
              
              // Tiny fast cars with weird movement
              { name: "Zippy Bug", w: 120, h: 80, color: "#ff1493", speed: 12.0, design: "bug", weirdMovement: true },
              { name: "Spinning Top", w: 100, h: 100, color: "#00ffff", speed: 10.0, design: "top", weirdMovement: true },
              { name: "Crazy Cube", w: 90, h: 90, color: "#ffff00", speed: 9.0, design: "cube", weirdMovement: true },
              { name: "Bouncing Ball", w: 80, h: 80, color: "#ff4500", speed: 11.0, design: "ball", weirdMovement: true },
              { name: "Dizzy Disc", w: 110, h: 60, color: "#9370db", speed: 10.5, design: "disc", weirdMovement: true }
            ];
            
            const carType = carTypes[Math.floor(Math.random() * carTypes.length)];
            const baseSpeed = carType.speed;
            
            // Try to find a non-overlapping position
            let attempts = 0;
            let newCar = null;
            
            while (attempts < 10 && !newCar) {
              const testX = chunkStartX + Math.random() * chunkSize;
              const testY = chunkStartY + Math.random() * chunkSize;
              
              // Check if position is within boundaries first
              if (!isWithinBoundaries(testX + carType.w/2, testY + carType.h/2)) {
                attempts++;
                continue;
              }
              
              // Check if this position overlaps with existing art cars
              let overlaps = false;
              for (let existingCar of artCars) {
                if (testX < existingCar.x + existingCar.w &&
                    testX + carType.w > existingCar.x &&
                    testY < existingCar.y + existingCar.h &&
                    testY + carType.h > existingCar.y) {
                  overlaps = true;
                  break;
                }
              }
              
              if (!overlaps) {
                let vx, vy;
                
                if (carType.weirdMovement) {
                  // Weird movement patterns for tiny fast cars
                  const patterns = [
                    // Diagonal zigzag
                    () => ({ vx: Math.random() > 0.5 ? baseSpeed : -baseSpeed, vy: Math.random() > 0.5 ? baseSpeed * 0.7 : -baseSpeed * 0.7 }),
                    // Spiral movement
                    () => ({ vx: baseSpeed * Math.cos(Date.now() * 0.001), vy: baseSpeed * Math.sin(Date.now() * 0.001) }),
                    // Random direction changes
                    () => ({ vx: (Math.random() - 0.5) * baseSpeed * 2, vy: (Math.random() - 0.5) * baseSpeed * 2 }),
                    // Figure-8 pattern
                    () => ({ vx: baseSpeed * Math.sin(Date.now() * 0.002), vy: baseSpeed * Math.sin(Date.now() * 0.001) }),
                    // Chaotic movement
                    () => ({ vx: (Math.random() - 0.5) * baseSpeed * 3, vy: (Math.random() - 0.5) * baseSpeed * 3 })
                  ];
                  
                  const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                  const velocity = pattern();
                  vx = velocity.vx;
                  vy = velocity.vy;
                } else {
                  // Normal movement for regular cars
                  vx = (Math.random() - 0.5) * baseSpeed;
                  vy = (Math.random() - 0.5) * baseSpeed;
                }
                
                newCar = {
                  x: testX,
                  y: testY,
                  w: carType.w, 
                  h: carType.h,
                  vx: vx,
                  vy: vy,
                  color: carType.color,
                  name: carType.name,
                  design: carType.design,
                  weirdMovement: carType.weirdMovement || false,
                  hasPassenger: false,
                  chunkId: chunkId,
                  fuel: Math.random() * 50 + 25, // 25-75 fuel units
                  maxFuel: 100,
                  flameIntensity: 0 // 0-1, increases with fuel
                };
              }
              
              attempts++;
            }
            
            // Only add the car if we found a non-overlapping position
            if (newCar) {
              artCars.push(newCar);
            }
          }
          
          // Generate gasoline tanks (rare, valuable fuel for mutant vehicles)
          const gasTankCount = Math.floor((Math.random() * 2 + 1) * worldPopulationMultiplier / 6); // Very rare - 1/6 rate
          for (let i = 0; i < gasTankCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              gasolineTanks.push({
                x: x,
                y: y,
                w: 20, h: 24, collected: false, chunkId: chunkId,
                fuelAmount: 10 // Each tank gives 10 fuel points
              });
            }
          }
          
          // Generate NPCs (survivors in the wasteland)
          const npcTypes = [
            { name: 'Dancer', emoji: '💃', behavior: 'dance', size: 20 },
            { name: 'Biker', emoji: '🚴', behavior: 'bike', size: 18 },
            { name: 'Art Car Passenger', emoji: '🎭', behavior: 'artcar', size: 16 }
          ];
          
          const npcCount = Math.floor((Math.random() * 3 + 2) * Math.max(worldPopulationMultiplier, 0.1)); // Minimum spawn rate
          for (let i = 0; i < npcCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              const npcType = npcTypes[Math.floor(Math.random() * npcTypes.length)];
              npcs.push({
                x: x,
                y: y,
                w: npcType.size,
                h: npcType.size,
                chunkId: chunkId,
                type: npcType.name,
                emoji: npcType.emoji,
                behavior: npcType.behavior,
                // Movement properties
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                // Behavior timers
                behaviorTimer: Math.random() * 300, // Random start time
                directionChangeTimer: Math.random() * 180,
                // Special properties
                hasGasCan: false,
                targetArtCar: null,
                karmaReward: 5 // Karma for helping this NPC
              });
            }
          }
          
          // Generate bikes (scaled by population)
          const bikeColors = ['#ff4757', '#2ed573', '#1e90ff', '#ffa502', '#ff6348', '#5f27cd'];
          const bikeCount = Math.floor((Math.random() * 6 + 3) * worldPopulationMultiplier / 3); // 1/3 rate
          for (let i = 0; i < bikeCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              const bike = {
                x: x,
                y: y,
                w: 72, h: 44, collected: false, chunkId: chunkId,
                color: bikeColors[Math.floor(Math.random() * bikeColors.length)]
              };
              bikes.push(bike);
            }
          }
          
          // Generate MOOP items (scaled by population)
          const moopTypes = [
            { name: 'Zip Tie', emoji: '🔗', karmaValue: 2, inventoryItem: false },
            { name: 'Clothing', emoji: '👕', karmaValue: 0, inventoryItem: true, moodBoost: 15, energyBoost: 10 },
            { name: 'Trinket', emoji: '✨', karmaValue: 0, inventoryItem: true, moodBoost: 12, energyBoost: 8 },
            { name: 'Flashing Light', emoji: '💡', karmaValue: 4, inventoryItem: false },
            { name: 'Cup', emoji: '🥤', karmaValue: 1, inventoryItem: false },
            { name: 'Cigarette Butt', emoji: '🚬', karmaValue: 1, inventoryItem: false }
          ];
          
          const moopCount = Math.floor((Math.random() * 10 + 5) * worldPopulationMultiplier);
          for (let i = 0; i < moopCount; i++) {
            const moopType = moopTypes[Math.floor(Math.random() * moopTypes.length)];
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              moop.push({
                x: x,
                y: y,
                w: 12, h: 12, collected: false, chunkId: chunkId,
                type: moopType.name,
                emoji: moopType.emoji,
                karmaValue: moopType.karmaValue,
                inventoryItem: moopType.inventoryItem || false,
                moodBoost: moopType.moodBoost || 0,
                energyBoost: moopType.energyBoost || 0
              });
            }
          }
          
          // Generate drugs (scaled by population)
          const drugTypes = [
            // Mystery pills - only Molly
            { name: 'Mystery Pill', emoji: '💊', speedMultiplier: 1.5, duration: 4, hallucinating: true, mysteryType: 'Molly', timeMultiplier: 0.8, specialEffects: 'molly' }, // 4 hours
            // Mystery snowballs - could be either Speed or Ketamine (50/50 chance)
            { name: 'Mystery Snowball', emoji: '⚪️', speedMultiplier: 2.0, duration: 2, hallucinating: false, mysteryType: 'Speed', timeMultiplier: 2.0 }, // 2 hours
            { name: 'Mystery Snowball', emoji: '⚪️', speedMultiplier: 0.3, duration: 3, hallucinating: true, mysteryType: 'Ketamine', timeMultiplier: 0.1 }, // 3 hours
            // Classic psychedelics
            { name: 'LSD', emoji: '🌈', speedMultiplier: 0.5, duration: 8, hallucinating: true, timeMultiplier: 0.3, specialEffects: 'acid' }, // 8 hours
            { name: 'Shrooms', emoji: '🍄', speedMultiplier: 0.7, duration: 6, hallucinating: true, timeMultiplier: 0.5, specialEffects: 'shrooms' }, // 6 hours
            { name: 'DMT', emoji: '💫', speedMultiplier: 0.2, duration: 0.5, hallucinating: true, timeMultiplier: 0.1, specialEffects: 'dmt' }, // 30 minutes
            { name: 'Mescaline', emoji: '🌵', speedMultiplier: 0.6, duration: 10, hallucinating: true, timeMultiplier: 0.4 }, // 10 hours
            // Stimulants
            { name: 'Caffeine', emoji: '☕', speedMultiplier: 1.3, duration: 1, hallucinating: false, timeMultiplier: 1.5, energyBoost: 15 }, // 1 hour
            { name: 'Cocaine', emoji: '❄️', speedMultiplier: 2.5, duration: 1.5, hallucinating: false, timeMultiplier: 2.5, energyBoost: 25 }, // 1.5 hours
            { name: 'Adderall', emoji: '💊', speedMultiplier: 1.8, duration: 4, hallucinating: false, timeMultiplier: 1.8, energyBoost: 20 }, // 4 hours
            { name: 'Energy Drink', emoji: '⚡', speedMultiplier: 1.4, duration: 0.5, hallucinating: false, timeMultiplier: 1.4, energyBoost: 12 }, // 30 minutes
            // Depressants
            { name: 'Xanax', emoji: '💙', speedMultiplier: 0.4, duration: 6, hallucinating: false, timeMultiplier: 0.3 }, // 6 hours
            { name: 'Valium', emoji: '💜', speedMultiplier: 0.5, duration: 8, hallucinating: false, timeMultiplier: 0.4 }, // 8 hours
            { name: 'Ambien', emoji: '😴', speedMultiplier: 0.2, duration: 8, hallucinating: true, timeMultiplier: 0.2 }, // 8 hours
            // Dissociatives
            { name: 'Ketamine', emoji: '🕳️', speedMultiplier: 0.3, duration: 2, hallucinating: true, timeMultiplier: 0.1 }, // 2 hours
            { name: 'PCP', emoji: '👻', speedMultiplier: 0.4, duration: 4, hallucinating: true, timeMultiplier: 0.2 }, // 4 hours
            // Special effects
            { name: 'Whip Its', emoji: '🎈', speedMultiplier: 1.0, duration: 0.15, hallucinating: false, moodBoost: 10, energyBoost: 5, timeMultiplier: 0, specialEffects: 'whipits' }, // 15 minutes - stops time
            { name: 'Salvia', emoji: '🌿', speedMultiplier: 0.1, duration: 0.25, hallucinating: true, timeMultiplier: 0.05, specialEffects: 'salvia' }, // 15 minutes
            { name: '2C-B', emoji: '🔮', speedMultiplier: 0.8, duration: 4, hallucinating: true, timeMultiplier: 0.6 }, // 4 hours
            // Common substances
            { name: 'Cigarette', emoji: '🚬', speedMultiplier: 1.0, duration: 0.5, hallucinating: false, moodBoost: 3, energyBoost: 2, timeMultiplier: 1.0 }, // 30 minutes
            { name: 'Joint', emoji: '🌿', speedMultiplier: 0.8, duration: 2, hallucinating: true, moodBoost: 8, energyBoost: -2, timeMultiplier: 0.7 }, // 2 hours
            { name: 'Alcohol', emoji: '🍺', speedMultiplier: 0.6, duration: 3, hallucinating: false, moodBoost: 5, energyBoost: -5, timeMultiplier: 1.0, specialEffects: 'alcohol' }, // 3 hours
            { name: 'Wine', emoji: '🍷', speedMultiplier: 0.7, duration: 2, hallucinating: false, moodBoost: 6, energyBoost: -3, timeMultiplier: 1.1, specialEffects: 'alcohol' }, // 2 hours
            { name: 'Vodka', emoji: '🥃', speedMultiplier: 0.4, duration: 4, hallucinating: false, moodBoost: 7, energyBoost: -8, timeMultiplier: 0.8, specialEffects: 'alcohol' }, // 4 hours
            // Party drugs
            { name: 'MDMA', emoji: '💎', speedMultiplier: 1.2, duration: 4, hallucinating: false, moodBoost: 15, energyBoost: 10, timeMultiplier: 1.1, specialEffects: 'molly' }, // 4 hours
            { name: 'MDA', emoji: '💠', speedMultiplier: 1.1, duration: 5, hallucinating: true, moodBoost: 12, energyBoost: 8, timeMultiplier: 0.9 }, // 5 hours
            { name: '2C-I', emoji: '✨', speedMultiplier: 0.9, duration: 6, hallucinating: true, timeMultiplier: 0.7 }, // 6 hours
            { name: 'DOB', emoji: '🌟', speedMultiplier: 0.6, duration: 12, hallucinating: true, timeMultiplier: 0.5 } // 12 hours
          ];
          
          const drugCount = Math.floor((Math.random() * 4 + 2) * Math.max(worldPopulationMultiplier, 0.1)); // Minimum spawn rate
          for (let i = 0; i < drugCount; i++) {
            const drugType = drugTypes[Math.floor(Math.random() * drugTypes.length)];
            
            // For Mystery Snowballs, randomly choose between Speed and Ketamine
            let actualDrugType = drugType;
            if (drugType.name === 'Mystery Snowball') {
              const isSpeed = Math.random() < 0.5; // 50% chance
              if (isSpeed) {
                actualDrugType = {
                  ...drugType,
                  speedMultiplier: 2.0,
                  duration: 2,
                  hallucinating: false,
                  mysteryType: 'Speed',
                  timeMultiplier: 2.0
                };
              } else {
                actualDrugType = {
                  ...drugType,
                  speedMultiplier: 0.3,
                  duration: 3,
                  hallucinating: true,
                  mysteryType: 'Ketamine',
                  timeMultiplier: 0.1
                };
              }
            }
            
            // For cigarettes, randomly choose between Cigarette and Joint
            if (drugType.name === 'Cigarette') {
              const isJoint = Math.random() < 0.5; // 50% chance
              if (isJoint) {
                actualDrugType = {
                  ...drugType,
                  name: 'Joint',
                  speedMultiplier: 0.8,
                  duration: 2,
                  hallucinating: true,
                  moodBoost: 8,
                  energyBoost: -2,
                  timeMultiplier: 0.7
                };
              } else {
                actualDrugType = {
                  ...drugType,
                  speedMultiplier: 1.0,
                  duration: 0.5,
                  hallucinating: false,
                  moodBoost: 3,
                  energyBoost: 2,
                  timeMultiplier: 1.0
                };
              }
            }
            
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              drugs.push({
                x: x,
                y: y,
                w: 20, h: 20, collected: false, chunkId: chunkId,
              type: actualDrugType.name,
              emoji: actualDrugType.emoji,
              speedMultiplier: actualDrugType.speedMultiplier,
              duration: actualDrugType.duration,
              hallucinating: actualDrugType.hallucinating,
              mysteryType: actualDrugType.mysteryType, // Include mystery type
              timeMultiplier: actualDrugType.timeMultiplier, // Include time multiplier
              specialEffects: actualDrugType.specialEffects // Include special effects
              });
            }
          }
          
          // Generate extra Whip Its (2x more frequent for time stopping effects)
          const whipItCount = Math.floor((Math.random() * 3 + 2) * worldPopulationMultiplier); // Normal Whip It spawn rate (reduced from 2x)
          for (let i = 0; i < whipItCount; i++) {
            const x = chunkStartX + Math.random() * chunkSize;
            const y = chunkStartY + Math.random() * chunkSize;
            
            // Only add if within boundaries
            if (isWithinBoundaries(x, y)) {
              drugs.push({
                x: x,
                y: y,
                w: 20, h: 20, collected: false, chunkId: chunkId,
                type: 'Whip Its',
                emoji: '🎈',
                speedMultiplier: 1.0,
                duration: 0.15,
                hallucinating: false,
                moodBoost: 10,
                energyBoost: 5,
                timeMultiplier: 0 // Stops time
              });
            }
          }
          
          // Generate special locations (scaled by population)
          if (Math.random() < 0.3 * worldPopulationMultiplier) { // Population-scaled chance
            const locationTypes = [
              { type: 'danceFloor', emoji: '💃', name: 'Dance Floor', size: 80 },
              { type: 'artInstallation', emoji: '🎨', name: 'Art Installation', size: 60 },
              { type: 'orgyDome', emoji: '🏕️', name: 'Orgy Dome', size: 100 },
              // Removed homeCamp - only player's home base should be generated
              { type: 'fuelStation', emoji: '⛽', name: 'Fuel Station', size: 90 }
            ];
            
            const location = locationTypes[Math.floor(Math.random() * locationTypes.length)];
            
            const locationObj = {
              x: chunkStartX + Math.random() * (chunkSize - location.size),
              y: chunkStartY + Math.random() * (chunkSize - location.size),
              w: location.size,
              h: location.size,
              type: location.type,
              emoji: location.emoji,
              name: location.name,
              chunkId: chunkId
            };
            
            switch (location.type) {
              case 'danceFloor':
                danceFloors.push(locationObj);
                break;
              case 'artInstallation':
                artInstallations.push(locationObj);
                break;
              case 'orgyDome':
                orgyDomes.push(locationObj);
                break;
              // Removed homeCamp case - only player's home base should be generated
              case 'fuelStation':
                fuelStations.push(locationObj);
                break;
            }
          }
        }
      }
    }

    // Generate the single center camp (only once)
    function generateCenterCamp() {
      // Only generate if no center camp exists
      if (centerCamps.length === 0) {
        // Position center camp between the yellow line (800px) and trash fence (1450px) on the bottom
        const centerCampX = 0; // Center horizontally
        const centerCampY = MAN_CIRCLE_RADIUS + 100; // Between yellow line and trash fence on bottom
        const centerCampSize = 120;
        
        // Make sure it's within boundaries
        if (isWithinBoundaries(centerCampX + centerCampSize/2, centerCampY + centerCampSize/2)) {
          centerCamps.push({
            x: centerCampX - centerCampSize/2,
            y: centerCampY - centerCampSize/2,
            w: centerCampSize,
            h: centerCampSize,
            type: 'centerCamp',
            emoji: '🏛️',
            name: 'Center Camp',
            chunkId: 'center-camp'
          });
        }
      }
    }
    
    // Generate the player's home base (only once)
    function generatePlayerHomeBase() {
      // Only generate if no player home base exists and hasn't been generated yet
      if (homeCamps.length === 0 && !playerHomeBaseGenerated) {
        // Position home base between yellow line (800px) and trash fence (1450px)
        // Avoid deep playa (10pm-2am) by staying closer to the yellow line
        const homeBaseDistance = MAN_CIRCLE_RADIUS + 200; // 1000px from center
        const homeBaseAngle = Math.random() * Math.PI * 2; // Random direction
        const homeBaseX = Math.cos(homeBaseAngle) * homeBaseDistance;
        const homeBaseY = Math.sin(homeBaseAngle) * homeBaseDistance;
        const homeBaseSize = 120;
        
        // Make sure it's within boundaries
        if (isWithinBoundaries(homeBaseX + homeBaseSize/2, homeBaseY + homeBaseSize/2)) {
          homeCamps.push({
            x: homeBaseX - homeBaseSize/2,
            y: homeBaseY - homeBaseSize/2,
            w: homeBaseSize,
            h: homeBaseSize,
            type: 'homeCamp',
            emoji: '🏕️',
            name: 'Boom Boom Womb',
            chunkId: 'player-home'
          });
          
          // Set player spawn location at the home base
          player.worldX = homeBaseX;
          player.worldY = homeBaseY;
          
          // Mark that the player's home base has been generated
          playerHomeBaseGenerated = true;
        }
      }
    }
    
    // Track generated chunks
    const generatedChunks = new Set();
    
    // Day/night cycle variables
    let lastTimeUpdate = Date.now(); // Initialize to current time instead of 0
    const SECONDS_PER_DAY = 24; // 24 seconds = 1 day
    
    // Burning Man timeline
    const BURNING_MAN_DURATION = 10; // 10 days total
    const MAN_BURN_DAY = 7; // Saturday (day 7) - Man burns (next Saturday night)
    const TEMPLE_BURN_DAY = 8; // Sunday (day 8) - Temple burns
    
    // Map boundaries and features
    const TEMPLE_DISTANCE = 750; // Distance from Man to Temple
    const PLAYA_RADIUS = TEMPLE_DISTANCE * 4; // Four times the temple distance = 3000 pixels (doubled)
    const MAN_CIRCLE_RADIUS = 800; // Radius of the circle around the Man
    const TRASH_FENCE_RADIUS = PLAYA_RADIUS - 50; // Inner radius of the trash fence
    
    // Progressive world population
    let dailyAnnouncements = [];
    let worldPopulationMultiplier = 0.1; // Start with 10% population
    let lastDisappearingDay = 0; // Track when we last ran disappearing logic
    let lastAnnouncedDay = 0; // Track which day we last announced
    
    // Game pause state
    let gamePaused = false;
    
    // World system
    let currentWorld = 'camp'; // 'camp' or 'playa'
    let campWorldGenerated = false;
    let playaWorldGenerated = false; // Track if playa world has been generated
    let playerHomeBaseGenerated = false; // Track if player's home base has been generated
    let hasExitedCampBefore = false; // Track if player has exited camp before
    let campExitTime = 0; // Timestamp when last exited camp (for 5s cooldown)
    
    // Man and Temple structures
    const manStructure = { 
      x: 0, y: 0, w: 80, h: 120, burned: false, 
      limbs: 0, maxLimbs: 7, // Start with 0 limbs, grow to 7 by day 8
      constructionProgress: 0 // 0-100% construction progress
    };
    const templeStructure = { 
      x: 0, y: -750, w: 100, h: 80, burned: false,
      constructionProgress: 0 // 0-100% construction progress
    };
    
    // Player state for art car riding
    let ridingArtCar = null;
    let lastExitTime = 0; // Track when we last exited an art car
    
    // Player state for bike riding
    let ridingBike = null;
    
    // Track nearby vehicles for boarding
    let nearbyArtCar = null;
    let nearbyBike = null;
    
    // Hearts overlay for Molly effects
    let mollyHearts = [];
    
    // Confetti for celebration
    let confetti = [];
    
    // Confetti particle class
    class ConfettiParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = -Math.random() * 8 - 2;
        this.gravity = 0.3;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        this.color = ['#ff6b35', '#f7931e', '#ffd23f', '#06ffa5', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'][Math.floor(Math.random() * 8)];
        this.size = Math.random() * 8 + 4;
        this.life = 120 + Math.random() * 60; // 2-3 seconds at 60fps
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.rotation += this.rotationSpeed;
        this.life--;
        this.vx *= 0.99; // Air resistance
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
      }
    }
    
    // Create confetti explosion
    function createConfettiExplosion(x, y, count = 50) {
      for (let i = 0; i < count; i++) {
        confetti.push(new ConfettiParticle(x + (Math.random() - 0.5) * 100, y + (Math.random() - 0.5) * 100));
      }
    }
    
    // Update confetti
    function updateConfetti() {
      confetti = confetti.filter(particle => {
        particle.update();
        return particle.life > 0;
      });
    }
    
    // Draw confetti
    function drawConfetti(ctx) {
      confetti.forEach(particle => particle.draw(ctx));
    }
    
    // Update transport buttons based on nearby vehicles and riding status
    function updateTransportButtons() {
      const transportActions = document.getElementById('transport-actions');
      const boardBtn = document.getElementById('board-btn');
      const dismountBtn = document.getElementById('dismount-btn');
      
      // Exit early if buttons don't exist yet
      if (!transportActions || !boardBtn || !dismountBtn) {
        return;
      }
      
      // Reset nearby vehicle detection
      nearbyArtCar = null;
      nearbyBike = null;
      let closestArtCarDistance = Infinity;
      
      // Check for nearby art cars - find the closest one
      artCars.forEach(car => {
        const distance = Math.sqrt(
          Math.pow(player.worldX + player.w/2 - (car.x + car.w/2), 2) + 
          Math.pow(player.worldY + player.h/2 - (car.y + car.h/2), 2)
        );
        
        if (distance < 60 && distance < closestArtCarDistance) {
          nearbyArtCar = car;
          closestArtCarDistance = distance;
          
          // Autoboard if touching and not already riding
          if (distance < 30 && ridingArtCar === null && Date.now() - lastExitTime > 3000) {
            // Auto-drop bike if riding one
            if (ridingBike) {
              ridingBike = null;
            }
            
            ridingArtCar = car;
            car.hasPassenger = true;
            // Position player in center of car platform
            player.worldX = car.x + car.w / 2 - player.w / 2;
            player.worldY = car.y + car.h / 2 - player.h / 2;
          }
        }
      });
      
      // Check for nearby bikes
      bikes.forEach(bike => {
        if (!bike.collected) {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (bike.x + bike.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (bike.y + bike.h/2), 2)
          );
          
          if (distance < 60) { // Adjusted for larger bikes
            nearbyBike = bike;
          }
        }
      });
      
      // Show/hide transport buttons based on state
      if (ridingArtCar || ridingBike) {
        // Show dismount button when riding something
        transportActions.style.display = 'grid';
        boardBtn.style.display = 'none';
        dismountBtn.style.display = 'block';
        dismountBtn.textContent = ridingArtCar ? `Dismount ${ridingArtCar.name}` : 'Dismount Bike [Space]';
      } else if (nearbyArtCar || nearbyBike) {
        // Show board button when near a vehicle
        transportActions.style.display = 'grid';
        boardBtn.style.display = 'block';
        dismountBtn.style.display = 'none';
        boardBtn.textContent = nearbyArtCar ? `Board ${nearbyArtCar.name}` : 'Ride Bike [Space]';
      } else {
        // Hide transport buttons when not near vehicles or riding
        transportActions.style.display = 'none';
      }
    }
    
    // Update bikes
    function updateBikes() {
      bikes.forEach(bike => {
        // If player is riding this bike, move it with the player
        if (ridingBike === bike) {
          // Center the bike on the player
          bike.x = player.worldX + player.w/2 - bike.w/2;
          bike.y = player.worldY + player.h/2 - bike.h/2;
          
        }
      });
    }
    
    // Update art cars
    function updateArtCars() {
      artCars.forEach(car => {
        // Store old position
        const oldX = car.x;
        const oldY = car.y;
        
        // Update weird movement patterns for tiny fast cars
        if (car.weirdMovement && Math.random() < 0.02) { // 2% chance each frame to change direction
          const patterns = [
            // Diagonal zigzag
            () => ({ vx: Math.random() > 0.5 ? car.vx : -car.vx, vy: Math.random() > 0.5 ? car.vy * 0.7 : -car.vy * 0.7 }),
            // Spiral movement
            () => ({ vx: Math.abs(car.vx) * Math.cos(Date.now() * 0.001), vy: Math.abs(car.vy) * Math.sin(Date.now() * 0.001) }),
            // Random direction changes
            () => ({ vx: (Math.random() - 0.5) * Math.abs(car.vx) * 2, vy: (Math.random() - 0.5) * Math.abs(car.vy) * 2 }),
            // Figure-8 pattern
            () => ({ vx: Math.abs(car.vx) * Math.sin(Date.now() * 0.002), vy: Math.abs(car.vy) * Math.sin(Date.now() * 0.001) }),
            // Chaotic movement
            () => ({ vx: (Math.random() - 0.5) * Math.abs(car.vx) * 3, vy: (Math.random() - 0.5) * Math.abs(car.vy) * 3 })
          ];
          
          const pattern = patterns[Math.floor(Math.random() * patterns.length)];
          const velocity = pattern();
          car.vx = velocity.vx;
          car.vy = velocity.vy;
        }
        
        // Move art car (2x faster)
        car.x += car.vx * 2;
        car.y += car.vy * 2;
        
        // Check for collision with other art cars
        let collided = false;
        for (let otherCar of artCars) {
          if (otherCar !== car) {
            if (car.x < otherCar.x + otherCar.w &&
                car.x + car.w > otherCar.x &&
                car.y < otherCar.y + otherCar.h &&
                car.y + car.h > otherCar.y) {
              // Collision detected - revert to old position and reverse direction
              car.x = oldX;
              car.y = oldY;
              car.vx *= -1;
              car.vy *= -1;
              collided = true;
              break;
            }
          }
        }
        
        // Bounce off edges (only if no collision with other cars)
        if (!collided) {
          if (car.x < 0 || car.x > 10000) car.vx *= -1;
          if (car.y < 0 || car.y > 10000) car.vy *= -1;
        }
        
        // If player is riding this car, move with it
        if (ridingArtCar === car) {
          // Player can move around on the car, but we need to track their offset from car center
          if (!car.playerOffset) {
            // Initialize player offset when first boarding
            car.playerOffset = { x: 0, y: 0 };
          }
          
          // Update player position based on car position + their offset
          const newPlayerX = car.x + car.w / 2 - player.w / 2 + car.playerOffset.x;
          const newPlayerY = car.y + car.h / 2 - player.h / 2 + car.playerOffset.y;
          
          // Check if player has walked off the art car platform
          const playerCenterX = newPlayerX + player.w / 2;
          const playerCenterY = newPlayerY + player.h / 2;
          const carCenterX = car.x + car.w / 2;
          const carCenterY = car.y + car.h / 2;
          const distanceFromCarCenter = Math.sqrt(
            Math.pow(playerCenterX - carCenterX, 2) + Math.pow(playerCenterY - carCenterY, 2)
          );
          
          // Auto-dismount if player is too far from car center (walked off the platform)
          if (distanceFromCarCenter > Math.max(car.w, car.h) / 2 + 20) {
            ridingArtCar.hasPassenger = false;
            lastExitTime = Date.now();
            ridingArtCar.playerOffset = null;
            ridingArtCar = null;
            return; // Skip the rest of the car update
          }
          
          // Keep player within car bounds
          const maxOffsetX = car.w / 2 - player.w / 2 - 10;
          const maxOffsetY = car.h / 2 - player.h / 2 - 10;
          
          car.playerOffset.x = Math.max(-maxOffsetX, Math.min(maxOffsetX, newPlayerX - (car.x + car.w / 2 - player.w / 2)));
          car.playerOffset.y = Math.max(-maxOffsetY, Math.min(maxOffsetY, newPlayerY - (car.y + car.h / 2 - player.h / 2)));
          
          player.worldX = car.x + car.w / 2 - player.w / 2 + car.playerOffset.x;
          player.worldY = car.y + car.h / 2 - player.h / 2 + car.playerOffset.y;
        }
        
        // Art car collision is now handled in the main update loop
        
        // Fuel consumption - only consume fuel when moving
        if (car.fuel !== undefined) {
          const movementSpeed = Math.sqrt(car.vx * car.vx + car.vy * car.vy);
          if (movementSpeed > 0.1) { // Only consume fuel when actually moving
            car.fuel -= movementSpeed * 0.02; // Consume fuel based on speed
            car.fuel = Math.max(0, car.fuel); // Don't go below 0
            
            // Update flame intensity based on fuel level
            car.flameIntensity = car.fuel / car.maxFuel;
            
            // Slow down when fuel is low
            if (car.fuel < 10) {
              car.vx *= 0.8;
              car.vy *= 0.8;
            } else if (car.fuel < 5) {
              car.vx *= 0.5;
              car.vy *= 0.5;
            } else if (car.fuel <= 0) {
              car.vx = 0;
              car.vy = 0;
            }
          }
        }
      });
    }
    
    // Update NPCs
    function updateNPCs() {
      npcs.forEach(npc => {
        // Update behavior timer
        npc.behaviorTimer--;
        npc.directionChangeTimer--;
        
        // Change direction occasionally
        if (npc.directionChangeTimer <= 0) {
          npc.vx = (Math.random() - 0.5) * 2;
          npc.vy = (Math.random() - 0.5) * 2;
          npc.directionChangeTimer = 180 + Math.random() * 120; // 3-5 seconds
        }
        
        // Check for gasoline tank pickup
        if (!npc.hasGasCan) {
          gasolineTanks.forEach(tank => {
            if (!tank.collected) {
              const distance = Math.sqrt(
                Math.pow(npc.x - tank.x, 2) + Math.pow(npc.y - tank.y, 2)
              );
              if (distance < 30 && Math.random() < 0.01) { // 1% chance per frame when nearby
                tank.collected = true;
                npc.hasGasCan = true;
                npc.gasCanFuel = tank.fuelAmount;
              }
            }
          });
        }
        
        // Check for art car fuel delivery
        if (npc.hasGasCan) {
          artCars.forEach(car => {
            const distance = Math.sqrt(
              Math.pow(npc.x - car.x, 2) + Math.pow(npc.y - car.y, 2)
            );
            if (distance < 50 && Math.random() < 0.02) { // 2% chance per frame when nearby
              // Deliver fuel to art car
              if (!car.fuel) car.fuel = 0;
              car.fuel += npc.gasCanFuel;
              car.fuel = Math.min(car.fuel, 100); // Cap at 100
              npc.hasGasCan = false;
              npc.gasCanFuel = 0;
              npc.karmaReward = Math.floor(Math.random() * 5) + 3; // 3-7 karma reward
            }
          });
        }
        
        // Behavior-specific logic
        switch (npc.behavior) {
          case 'camp':
            // Camp wombats move around slowly and randomly within camp boundaries
            if (npc.behaviorTimer <= 0) {
              // Random direction change
              const angle = Math.random() * Math.PI * 2;
              npc.vx = Math.cos(angle) * 1.0; // Slower movement in camp
              npc.vy = Math.sin(angle) * 1.0;
              npc.behaviorTimer = 180 + Math.random() * 120; // 3-5 seconds
            }
            
            // Keep wombats within camp boundaries
            if (npc.x < -380) {
              npc.x = -380;
              npc.vx = Math.abs(npc.vx); // Bounce off left wall
            }
            if (npc.x > 380) {
              npc.x = 380;
              npc.vx = -Math.abs(npc.vx); // Bounce off right wall
            }
            if (npc.y < -280) {
              npc.y = -280;
              npc.vy = Math.abs(npc.vy); // Bounce off top wall
            }
            if (npc.y > 280) {
              npc.y = 280;
              npc.vy = -Math.abs(npc.vy); // Bounce off bottom wall
            }
            break;
            
          case 'dance':
            // Dancers move in circular patterns
            if (npc.behaviorTimer <= 0) {
              const angle = Math.random() * Math.PI * 2;
              npc.vx = Math.cos(angle) * 1.5;
              npc.vy = Math.sin(angle) * 1.5;
              npc.behaviorTimer = 120 + Math.random() * 60; // 2-3 seconds
            }
            break;
            
          case 'bike':
            // Bikers move in straight lines with occasional turns
            if (npc.behaviorTimer <= 0) {
              const angle = Math.random() * Math.PI * 2;
              npc.vx = Math.cos(angle) * 3;
              npc.vy = Math.sin(angle) * 3;
              npc.behaviorTimer = 240 + Math.random() * 120; // 4-6 seconds
            }
            break;
            
          case 'artcar':
            // Art car passengers look for nearby art cars to board
            if (!npc.targetArtCar || npc.targetArtCar.hasPassenger) {
              // Find nearest available art car
              let nearestCar = null;
              let nearestDistance = Infinity;
              
              artCars.forEach(car => {
                if (!car.hasPassenger) {
                  const distance = Math.sqrt(
                    Math.pow(npc.x - car.x, 2) + Math.pow(npc.y - car.y, 2)
                  );
                  if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestCar = car;
                  }
                }
              });
              
              npc.targetArtCar = nearestCar;
            }
            
            // Move toward target art car
            if (npc.targetArtCar && !npc.targetArtCar.hasPassenger) {
              const dx = npc.targetArtCar.x - npc.x;
              const dy = npc.targetArtCar.y - npc.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance > 30) {
                npc.vx = (dx / distance) * 2;
                npc.vy = (dy / distance) * 2;
              } else {
                // Close enough to board
                npc.targetArtCar.hasPassenger = true;
                npc.x = npc.targetArtCar.x + npc.targetArtCar.w / 2 - npc.w / 2;
                npc.y = npc.targetArtCar.y + npc.targetArtCar.h / 2 - npc.h / 2;
                npc.vx = npc.targetArtCar.vx;
                npc.vy = npc.targetArtCar.vy;
              }
            }
            break;
        }
        
        // Update position
        npc.x += npc.vx;
        npc.y += npc.vy;
        
        // Bounce off world edges
        if (npc.x < 0 || npc.x > 10000) npc.vx *= -1;
        if (npc.y < 0 || npc.y > 10000) npc.vy *= -1;
        
        // Keep NPCs within bounds
        npc.x = Math.max(0, Math.min(10000 - npc.w, npc.x));
        npc.y = Math.max(0, Math.min(10000 - npc.h, npc.y));
      });
    }
    
    // Generate initial world content
    generateWorldContent();
    
    // Stat decay timer
    let lastStatDecay = Date.now();
    const statDecayInterval = 3000; // 3 seconds
    
    // Utility functions
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function rnd(p) { return Math.random() < p; }
    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    
    // Encounters from text version
    const encounters = [
      { 
        id: 'cuddle', 
        text: 'You stumble into a cuddle puddle under a parachute shade.', 
        choices: [
          { label: 'Ask for consent and join', eff: function(s) { s.mood += 10; s.karma += 5; s.energy += 5; } },
          { label: 'Politely decline and gift a snack', eff: function(s) { s.karma += 3; s.coin -= 1; } },
          { label: 'Dive in without asking (rude)', eff: function(s) { s.karma -= 10; s.mood -= 10; } }
        ]
      },
      { 
        id: 'orgy', 
        text: 'You find a velvet tent with a discreet sign. A ranger raises an eyebrow.', 
        choices: [
          { label: 'Ask the host for rules (consent + hygiene)', eff: function(s) { s.karma += 5; s.mood += 5; } },
          { label: 'Decide it\'s not for you, offer water at the door', eff: function(s) { s.karma += 4; s.coin -= 1; } },
          { label: 'Sneak photos (not cool)', eff: function(s) { s.karma -= 20; s.mood -= 15; } }
        ]
      },
      { 
        id: 'moop', 
        text: 'Wind scatters sequins—MOOP alert! Do you pitch in?', 
        choices: [
          { label: 'Lead a micro-MOOP sweep', eff: function(s) { s.karma += 6; s.coin += 2; s.energy -= 5; } },
          { label: 'Pick up a few pieces', eff: function(s) { s.karma += 2; } },
          { label: 'Ignore it', eff: function(s) { s.karma -= 4; } }
        ]
      },
      { 
        id: 'storm', 
        text: 'A dust storm rolls in. Visibility drops.', 
        onEnter: function() { player.flags.storm = true; }, 
        onExit: function() { player.flags.storm = false; }, 
        choices: [
          { label: 'Shelter in place', eff: function(s) { s.energy += 5; s.thirst -= 5; } },
          { label: 'Wander (thirst drains faster)', eff: function(s) { s.thirst -= 15; s.mood += 2; } },
          { label: 'Put on goggles and dance', eff: function(s) { s.mood += 6; s.thirst -= 10; } }
        ]
      },
      { 
        id: 'loot', 
        text: 'You find a neon cape and a mysterious lost sock.', 
        choices: [
          { label: 'Take cape (+night energy)', eff: function(s) { invPush('Neon Cape'); s.mood += 3; } },
          { label: 'Take sock (+1 luck… probably)', eff: function(s) { invPush('Lost Sock'); s.karma += 1; } },
          { label: 'Gift them forward', eff: function(s) { s.karma += 5; } }
        ]
      }
    ];

    // Time advancement function
    function advance(minutes) {
      player.time.minute += minutes;
      while (player.time.minute >= 60) { 
        player.time.minute -= 60; 
        player.time.hour++; 
      }
      while (player.time.hour >= 24) { 
        player.time.hour -= 24; 
        player.time.day++; 
      }
      
      const blocks = Math.max(1, Math.floor(minutes / 30));
      for (let i = 0; i < blocks; i++) {
        player.stats.hunger = clamp(player.stats.hunger - 3, 0, 100);
        player.stats.thirst = clamp(player.stats.thirst - (player.flags.storm ? 6 : 4), 0, 100);
        if (player.stats.thirst <= 20) player.stats.energy = clamp(player.stats.energy - 3, 0, 100);
        
        // Enhanced mood system - heavily impacted by basic needs
        let moodChange = 0;
        
        // Thirst heavily impacts mood
        if (player.stats.thirst <= 10) moodChange -= 8; // Very dehydrated = very grumpy
        else if (player.stats.thirst <= 25) moodChange -= 4; // Dehydrated = grumpy
        else if (player.stats.thirst <= 40) moodChange -= 2; // Thirsty = slightly grumpy
        
        // Energy heavily impacts mood
        if (player.stats.energy <= 5) moodChange -= 10; // Exhausted = very grumpy
        else if (player.stats.energy <= 15) moodChange -= 6; // Very tired = grumpy
        else if (player.stats.energy <= 30) moodChange -= 3; // Tired = slightly grumpy
        
        // Hunger impacts mood
        if (player.stats.hunger <= 20) moodChange -= 3; // Hungry = grumpy
        else if (player.stats.hunger <= 40) moodChange -= 1; // Slightly hungry
        
        // Sleep deprivation (if sleeping flag exists)
        if (player.sleeping) {
          moodChange += 2; // Sleeping makes you happier
        } else if (player.stats.energy <= 20) {
          moodChange -= 2; // Need sleep = grumpy
        }
        
        // Apply mood change
        player.stats.mood = clamp(player.stats.mood + moodChange, 0, 100);
      }
      // Only update time display in playa mode (camp time is handled separately)
      if (currentWorld === 'playa') {
      updateTimeDisplay();
      }
    }
    
    // Inventory functions
    function invPush(name) {
      if (player.inventory[name]) {
        player.inventory[name]++;
      } else {
        player.inventory[name] = 1;
      }
      updateInventoryDisplay();
    }
    
    function useItem(name, effect) {
      if (player.inventory[name] && player.inventory[name] > 0) {
        player.inventory[name]--;
        if (player.inventory[name] === 0) {
          delete player.inventory[name];
        }
        applyEff(effect);
        updateInventoryDisplay();
        return true;
      }
      return false;
    }
    
    // Effect application
    function applyEff(fn) {
      const s = player.stats;
      fn(s);
      s.coin = clamp(s.coin, 0, 9999);
      s.karma = clamp(s.karma, 0, 9999);
      s.hunger = clamp(s.hunger, 0, 100);
      s.thirst = clamp(s.thirst, 0, 100);
      s.energy = clamp(s.energy, 0, 100);
      s.mood = clamp(s.mood, 0, 100);
      updateStatsDisplay();
    }

    document.addEventListener("keydown", e => { 
      keys[e.key] = true; 
      
      // R hotkey for rest/wake up
      if (e.key.toLowerCase() === 'r' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        if (player.sleeping) {
          // Wake up if sleeping
          player.sleeping = false;
          showCollectionFeedback('Woke up early!', 'energy', 0);
        } else {
          // Start napping if not sleeping
          actions.rest();
        }
        return;
      }
      
      // C hotkey for climbing decorative blocks (only when near decorative blocks)
      if (e.key.toLowerCase() === 'c' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        // Check if player is near a decorative block
        let nearBlock = false;
        let closestDistance = Infinity;
        
        decorations.forEach(decoration => {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (decoration.x + decoration.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (decoration.y + decoration.h/2), 2)
          );
          if (distance < closestDistance) {
            closestDistance = distance;
          }
          if (distance < 60) { // Increased distance for easier activation
            nearBlock = true;
          }
        });
        
        if (nearBlock) {
          actions.climb();
        } else {
          showCollectionFeedback('No decorative blocks nearby to climb!', 'mood', 0);
        }
        return;
      }
      
      // H hotkey for chores (only when at home camps)
      if (e.key.toLowerCase() === 'h' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        // Check if player is at a home camp
        let atHome = false;
        homeCamps.forEach(camp => {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (camp.x + camp.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (camp.y + camp.h/2), 2)
          );
          if (distance < 80) {
            atHome = true;
          }
        });
        
        if (atHome) {
          actions.chore();
        } else {
          showCollectionFeedback('You need to be at home to do chores!', 'mood', 0);
        }
        return;
      }
      
      // D hotkey for dancing (only when on dance floors)
      if (e.key.toLowerCase() === 'd' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        // Check if player is on a dance floor
        let onDanceFloor = false;
        danceFloors.forEach(floor => {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (floor.x + floor.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (floor.y + floor.h/2), 2)
          );
          if (distance < 80) {
            onDanceFloor = true;
          }
        });
        
        if (onDanceFloor) {
          actions.dance();
        } else {
          showCollectionFeedback('You need to be on a dance floor to dance!', 'mood', 0);
        }
        return;
      }
      
      // O hotkey for orgy (only when at orgy domes)
      if (e.key.toLowerCase() === 'o' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        // Check if player is at an orgy dome
        let atOrgyDome = false;
        orgyDomes.forEach(dome => {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (dome.x + dome.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (dome.y + dome.h/2), 2)
          );
          if (distance < 80) {
            atOrgyDome = true;
          }
        });
        
        if (atOrgyDome) {
          actions.orgy();
        } else {
          showCollectionFeedback('You need to be at an orgy dome to participate!', 'mood', 0);
        }
        return;
      }
      
      // B hotkey for shopping (only when at center camps)
      if (e.key.toLowerCase() === 'b' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        // Check if player is at a center camp
        let atCenterCamp = false;
        centerCamps.forEach(camp => {
          const distance = Math.sqrt(
            Math.pow(player.worldX + player.w/2 - (camp.x + camp.w/2), 2) + 
            Math.pow(player.worldY + player.h/2 - (camp.y + camp.h/2), 2)
          );
          if (distance < 80) {
            atCenterCamp = true;
          }
        });
        
        if (atCenterCamp) {
          actions.shop();
        } else {
          showCollectionFeedback('You need to be at Center Camp to shop!', 'mood', 0);
        }
        return;
      }
      
      
      // Spacebar for bike control
      if (e.key === ' ' && !e.repeat) { // Prevent key repeat
        e.preventDefault();
        if (ridingBike) {
          // Dismount bike
          actions.dismount();
        } else if (nearbyBike) {
          // Mount bike
          actions.board();
        }
        return;
      }
      
      // Wake up from sleep with any key (except movement keys)
      if (player.sleeping && !['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
        player.sleeping = false;
        showCollectionFeedback('Woke up early!', 'energy', 0);
        return;
      }
      
      // G hotkey for giving gifts
      if (e.key.toLowerCase() === 'g' && !document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        e.preventDefault();
        actions.gift();
        return;
      }
      
      // Inventory hotkeys (only process if not in a modal or input)
      if (!document.querySelector('.encounter-modal') && !e.target.matches('input, textarea')) {
        // Water - W
        if (e.key.toLowerCase() === 'w') {
          e.preventDefault();
          if (player.inventory['Water'] && player.inventory['Water'] > 0) {
            if (!useItem('Water', function(s) { s.thirst += 35; s.mood += 3; })) {
              alert('No water left.');
            }
          }
        }
        
        // Trinket - T
        else if (e.key.toLowerCase() === 't') {
          e.preventDefault();
          if (player.inventory['Trinket'] && player.inventory['Trinket'] > 0) {
            if (!useItem('Trinket', function(s) { s.mood += 12; s.energy += 8; })) {
              alert('No trinkets left.');
            }
          }
        }
        
        // Clothing - L (avoiding C conflict with climb)
        else if (e.key.toLowerCase() === 'l') {
          e.preventDefault();
          if (player.inventory['Clothing'] && player.inventory['Clothing'] > 0) {
            if (!useItem('Clothing', function(s) { s.mood += 15; s.energy += 10; })) {
              alert('No clothing left.');
            }
          }
        }
        
        // Food hotkeys - first letter of each food (avoiding conflicts)
        else if (e.key.toLowerCase() === 'j') { // J for grilled cheese (avoiding G conflict)
          e.preventDefault();
          if (player.inventory['Grilled Cheese'] && player.inventory['Grilled Cheese'] > 0) {
            if (!useItem('Grilled Cheese', function(s) { s.hunger += 25; s.mood += 8; })) {
              alert('No grilled cheese left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'v') {
          e.preventDefault();
          if (player.inventory['Veggie Burger'] && player.inventory['Veggie Burger'] > 0) {
            if (!useItem('Veggie Burger', function(s) { s.hunger += 35; s.mood += 10; })) {
              alert('No veggie burger left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'f') {
          e.preventDefault();
          if (player.inventory['Fruit Salad'] && player.inventory['Fruit Salad'] > 0) {
            if (!useItem('Fruit Salad', function(s) { s.hunger += 20; s.mood += 6; })) {
              alert('No fruit salad left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'e') {
          e.preventDefault();
          if (player.inventory['Energy Bar'] && player.inventory['Energy Bar'] > 0) {
            if (!useItem('Energy Bar', function(s) { s.hunger += 15; s.mood += 4; s.energy += 20; })) {
              alert('No energy bar left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'p') {
          e.preventDefault();
          if (player.inventory['Pizza Slice'] && player.inventory['Pizza Slice'] > 0) {
            if (!useItem('Pizza Slice', function(s) { s.hunger += 30; s.mood += 12; })) {
              alert('No pizza slice left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 's') {
          e.preventDefault();
          if (player.inventory['Smoothie'] && player.inventory['Smoothie'] > 0) {
            if (!useItem('Smoothie', function(s) { s.hunger += 18; s.mood += 5; })) {
              alert('No smoothie left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'o') {
          e.preventDefault();
          if (player.inventory['Popsicle'] && player.inventory['Popsicle'] > 0) {
            if (!useItem('Popsicle', function(s) { s.hunger += 8; s.mood += 3; })) {
              alert('No popsicle left.');
            }
          } else {
          }
        }
        else if (e.key.toLowerCase() === 'u') {
          e.preventDefault();
          if (player.inventory['Burrito'] && player.inventory['Burrito'] > 0) {
            if (!useItem('Burrito', function(s) { s.hunger += 28; s.mood += 9; })) {
              alert('No burrito left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'k') {
          e.preventDefault();
          if (player.inventory['Taco'] && player.inventory['Taco'] > 0) {
            if (!useItem('Taco', function(s) { s.hunger += 22; s.mood += 7; })) {
              alert('No taco left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'i') {
          e.preventDefault();
          if (player.inventory['Ice Cream'] && player.inventory['Ice Cream'] > 0) {
            if (!useItem('Ice Cream', function(s) { s.hunger += 12; s.mood += 6; })) {
              alert('No ice cream left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'n') {
          e.preventDefault();
          if (player.inventory['Corn Dog'] && player.inventory['Corn Dog'] > 0) {
            if (!useItem('Corn Dog', function(s) { s.hunger += 25; s.mood += 8; })) {
              alert('No corn dog left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'm') {
          e.preventDefault();
          if (player.inventory['Funnel Cake'] && player.inventory['Funnel Cake'] > 0) {
            if (!useItem('Funnel Cake', function(s) { s.hunger += 20; s.mood += 10; })) {
              alert('No funnel cake left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'q') {
          e.preventDefault();
          if (player.inventory['Nachos'] && player.inventory['Nachos'] > 0) {
            if (!useItem('Nachos', function(s) { s.hunger += 24; s.mood += 7; })) {
              alert('No nachos left.');
            }
          }
        }
        else if (e.key.toLowerCase() === 'y') {
          e.preventDefault();
          if (player.inventory['Cotton Candy'] && player.inventory['Cotton Candy'] > 0) {
            if (!useItem('Cotton Candy', function(s) { s.hunger += 5; s.mood += 2; })) {
              alert('No cotton candy left.');
            }
          }
        }
        // Note: 'R' is already used for rest, 'H' for chores, 'G' for gifts
        // So Pretzel uses 'R' but conflicts with rest - we'll skip it for now
      }
    });
    document.addEventListener("keyup", e => { keys[e.key] = false; });
    
    // Canvas click handling removed - now using buttons for boarding/dismounting
    
    function updateDayNightCycle() {
      const now = Date.now();
      
      // Safety check: if lastTimeUpdate is 0 or very old, reset it
      if (lastTimeUpdate === 0 || (now - lastTimeUpdate) > 10000) {
        console.log('WARNING: Time system stuck, resetting lastTimeUpdate');
        lastTimeUpdate = now;
      }
      
      if (now - lastTimeUpdate > 1000) { // Update every second
        
        // Update lastTimeUpdate immediately to prevent getting stuck
        lastTimeUpdate = now;
        
        // In camp mode, time advances 1 minute per second (real-time)
        if (currentWorld === 'camp') {
          // Advance time by 1 minute every second in camp
          player.time.minute += 1;
          
          // Handle minute overflow
          while (player.time.minute >= 60) {
            player.time.minute -= 60;
            player.time.hour += 1;
            
            // Handle hour overflow
            while (player.time.hour >= 24) {
              player.time.hour -= 24;
              player.time.day++;
            }
          }
          
          // Update time display and return (no other time logic needed in camp)
          updateTimeDisplay();
          return;
        }
        
        
        // Handle time stop (Whip Its effect)
        if (player.drugEffects.timeStopDuration > 0) {
          player.drugEffects.timeStopDuration--;
          
          // Safety check: if timeStopDuration is stuck for too long, reset it
          if (player.drugEffects.timeStopDuration > 10) {
            player.drugEffects.timeStopDuration = 0;
          } else {
            return; // Skip time progression while time is stopped
          }
        }
        
        // Calculate time multiplier from active drugs (only for playa world)
        let timeMultiplier = 1.0;
        if (currentWorld === 'playa') {
          player.drugEffects.activeDrugs.forEach(drug => {
            if (drug.timeMultiplier !== undefined && drug.timeMultiplier !== 0) {
              timeMultiplier *= drug.timeMultiplier;
            }
          });
          
          // Ensure timeMultiplier is never 0 (which would freeze time)
          if (timeMultiplier === 0) {
            timeMultiplier = 0.1;
          }
          
          // Cap timeMultiplier to prevent extreme values that could cause performance issues
          if (timeMultiplier > 10) {
            timeMultiplier = 10;
          }
          if (timeMultiplier < 0.01) {
            timeMultiplier = 0.01;
          }
        }
        
        // Debug logging removed for cleaner console
        
          // Advance time by 1 minute every second in playa mode, modified by drug effects
          const previousDay = player.time.day;
          
          if (currentWorld === 'playa') {
            // In playa mode, advance 1 minute per second (instead of 1 hour per second)
            // For time speed effects, we need to accumulate fractional time
            if (!player.drugEffects.timeAccumulator) {
              player.drugEffects.timeAccumulator = 0;
            }
            
            const oldAccumulator = player.drugEffects.timeAccumulator;
            player.drugEffects.timeAccumulator += timeMultiplier;
            
            // Only advance time when we've accumulated enough (1 minute = 1/60 of an hour)
            let minutesAdvanced = 0;
            const maxMinutesPerUpdate = 1440; // Prevent advancing more than 24 hours in one update
            
            while (player.drugEffects.timeAccumulator >= (1/60) && minutesAdvanced < maxMinutesPerUpdate) {
              player.drugEffects.timeAccumulator -= (1/60);
              player.time.minute += 1;
              minutesAdvanced++;
              
              // Handle minute overflow
              while (player.time.minute >= 60) {
                player.time.minute -= 60;
                player.time.hour += 1;
                
                // Handle hour overflow
                while (player.time.hour >= 24) {
                  player.time.hour -= 24;
                  player.time.day++;
                  
                  // Update cooldowns when day advances
                  if (player.cooldowns.dance > 0) player.cooldowns.dance--;
                  if (player.cooldowns.climb > 0) player.cooldowns.climb--;
                  if (player.cooldowns.orgy > 0) player.cooldowns.orgy--;
                  if (player.cooldowns.chore > 0) player.cooldowns.chore--;
                  if (player.cooldowns.shop > 0) player.cooldowns.shop--;
                }
              }
            }
            
            // Safety check: if we hit the limit, reset accumulator to prevent getting stuck
            if (minutesAdvanced >= maxMinutesPerUpdate) {
              player.drugEffects.timeAccumulator = 0;
            }
          }
        
        // Announce new day at midnight (00:00) and update world population
        if (player.time.day > previousDay && player.time.hour === 0) {
          showDayAnnouncement(player.time.day);
          lastAnnouncedDay = player.time.day;
          
          // Dynamic playa population based on timeline
          if (player.time.day < MAN_BURN_DAY) {
            // Growing population - reaches peak on Man Burn day
            const daysToPeak = MAN_BURN_DAY - 1;
            const progress = (player.time.day - 1) / daysToPeak;
            worldPopulationMultiplier = 0.1 + (0.9 * progress); // 10% to 100%
          } else if (player.time.day === MAN_BURN_DAY) {
            // Peak population on Man Burn day
            worldPopulationMultiplier = 1.0;
          } else if (player.time.day === 9) {
            // Day 9: 50% of items disappear
            worldPopulationMultiplier = 0.5;
          } else if (player.time.day === 10) {
            // Day 10: Almost everything disappears, only 5% remains
            worldPopulationMultiplier = 0.05;
          } else {
            // Year 2069: Only mutant vehicles and scavenger campers remain
            worldPopulationMultiplier = 0.05; // 5% population - the last survivors
          }
          
          // Check for game end at end of day 10 (when transitioning to day 11)
          if (player.time.day === 11 && previousDay === 10) {
            setTimeout(() => {
              endGameFunction();
            }, 2000); // Wait 2 seconds after the day 10 announcement
          }
        }
        
        // Update time display
        updateTimeDisplay();
        
        // Update drug effects (decrement duration every hour)
        player.drugEffects.activeDrugs = player.drugEffects.activeDrugs.filter(drug => {
          drug.duration--;
          return drug.duration > 0;
        });
        
        // Update Man and Temple construction
        updateStructures();
        
        // Handle post-Burn disappearing items (only at midnight to avoid performance issues)
        if (player.time.hour === 0) {
          handlePostBurnDisappearing();
        }
        
        // Apply gradual stat decay (only in playa mode, not in camp)
        if (currentWorld === 'playa') {
          player.stats.hunger = Math.max(0, player.stats.hunger - 0.1);
          player.stats.thirst = Math.max(0, player.stats.thirst - 0.15);
          if (player.stats.thirst <= 20) player.stats.energy = Math.max(0, player.stats.energy - 0.05);
          
          // Enhanced gradual mood decay based on basic needs
          let gradualMoodChange = 0;
          
          // Thirst impacts mood gradually
          if (player.stats.thirst <= 10) gradualMoodChange -= 0.3; // Very dehydrated
          else if (player.stats.thirst <= 25) gradualMoodChange -= 0.2; // Dehydrated
          else if (player.stats.thirst <= 40) gradualMoodChange -= 0.1; // Thirsty
          
          // Energy impacts mood gradually
          if (player.stats.energy <= 5) gradualMoodChange -= 0.4; // Exhausted
          else if (player.stats.energy <= 15) gradualMoodChange -= 0.25; // Very tired
          else if (player.stats.energy <= 30) gradualMoodChange -= 0.15; // Tired
          
          // Hunger impacts mood gradually
          if (player.stats.hunger <= 20) gradualMoodChange -= 0.15; // Hungry
          else if (player.stats.hunger <= 40) gradualMoodChange -= 0.05; // Slightly hungry
          
          // Sleep deprivation
          if (!player.sleeping && player.stats.energy <= 20) {
            gradualMoodChange -= 0.1; // Need sleep
          }
          
          player.stats.mood = Math.max(0, player.stats.mood + gradualMoodChange);
        }
        
        // Update stats display
        updateStatsDisplay();
      }
      
      // Update displays only in playa mode (camp time is already updated in the camp section above)
      if (currentWorld === 'playa') {
        updateTimeDisplay();
        updateStatsDisplay(); // Also update stats display for time multiplier changes
      }
    }

    function update() {
      // Don't update if game has ended
      if (gameState.ended) return;
      
      // Track trip stats
      player.tripStats.totalPlayTime++;
      if (player.drugEffects.activeDrugs.length > 0) {
        player.tripStats.timeHigh++;
      }
      
      // Track distance traveled
      const distanceMoved = Math.sqrt(
        Math.pow(player.worldX - player.tripStats.lastX, 2) + 
        Math.pow(player.worldY - player.tripStats.lastY, 2)
      );
      player.tripStats.totalDistance += distanceMoved;
      player.tripStats.lastX = player.worldX;
      player.tripStats.lastY = player.worldY;
      
      // Countdown frame-based cooldowns
      if (player.cooldowns.homeSpawn > 0) {
        player.cooldowns.homeSpawn--;
      }
      
      // Track mood, energy, and speed states
      if (player.stats.mood > 80) {
        player.tripStats.highMoodTime++;
      } else if (player.stats.mood < 20) {
        player.tripStats.lowMoodTime++;
      }
      
      if (player.stats.energy > 80) {
        player.tripStats.wellRestedTime++;
      } else if (player.stats.energy < 20) {
        player.tripStats.exhaustedTime++;
      }
      
      // Calculate current speed multiplier for tracking
      let currentSpeedMultiplier = 1;
      if (ridingBike) currentSpeedMultiplier *= 1.5;
      
      // Add drug speed multipliers
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.speedMultiplier !== undefined && !isNaN(drug.speedMultiplier)) {
          currentSpeedMultiplier *= drug.speedMultiplier;
        }
      });
      
      // Add stat-based speed multipliers
      const energyMultiplier = 0.3 + (player.stats.energy / 100) * 0.9;
      const thirstMultiplier = 0.4 + (player.stats.thirst / 100) * 0.7;
      const hungerMultiplier = 0.5 + (player.stats.hunger / 100) * 0.6;
      const moodMultiplier = 0.5 + (player.stats.mood / 100) * 0.5;
      
      currentSpeedMultiplier *= energyMultiplier * thirstMultiplier * hungerMultiplier * moodMultiplier;
      
      // Track speed states
      if (currentSpeedMultiplier > 1.2) {
        player.tripStats.fastTime++;
      } else if (currentSpeedMultiplier < 0.8) {
        player.tripStats.slowTime++;
      }
      
      // Track movement modes
      if (ridingBike) {
        player.tripStats.bikingTime++;
      } else if (ridingArtCar) {
        player.tripStats.artCarTime++;
      } else {
        player.tripStats.walkingTime++;
      }
      
      // Handle sleeping state
      if (player.sleeping) {
        // Restore energy while sleeping (1 energy per second)
        player.stats.energy = Math.min(100, player.stats.energy + 1);
        
        // Wake up if energy is full
        if (player.stats.energy >= 100) {
          player.sleeping = false;
          showCollectionFeedback('Woke up fully rested!', 'energy', 0);
        }
        
        // Update stats display to show energy restoration
        updateStatsDisplay();
      }
      
      // Movement in world coordinates
      if (ridingArtCar === null) {
        // Debug movement state
        if (keys["ArrowUp"] || keys["ArrowLeft"] || keys["ArrowDown"] || keys["ArrowRight"]) {
        }
        // Calculate speed (1.5x when riding bike, modified by drug effects)
        let baseSpeed = ridingBike ? player.speed * 1.5 : player.speed;
        
        // Apply speed effects from all active drugs
        let speedMultiplier = 1;
        player.drugEffects.activeDrugs.forEach(drug => {
          speedMultiplier *= drug.speedMultiplier;
        });
        
        // Add stat-based speed multipliers for all stats
        const stats = player.stats;
        
        // Energy multiplier (0.3x to 1.2x based on energy level)
        const energyMultiplier = 0.3 + (stats.energy / 100) * 0.9;
        
        // Thirst multiplier (0.4x to 1.1x based on thirst level)
        const thirstMultiplier = 0.4 + (stats.thirst / 100) * 0.7;
        
        // Hunger multiplier (0.5x to 1.1x based on hunger level)
        const hungerMultiplier = 0.5 + (stats.hunger / 100) * 0.6;
        
        // Mood multiplier (0.6x to 1.2x based on mood level)
        const moodMultiplier = 0.6 + (stats.mood / 100) * 0.6;
        
        // Apply all stat multipliers
        speedMultiplier *= energyMultiplier * thirstMultiplier * hungerMultiplier * moodMultiplier;
        
        // Add visual feedback for low stats
        if (Math.random() < 0.005) { // 0.5% chance per frame to show feedback
          if (stats.energy < 20) {
            showCollectionFeedback('Low Energy - Moving Slowly!', 'energy', 0);
          } else if (stats.thirst < 20) {
            showCollectionFeedback('Dehydrated - Moving Slowly!', 'thirst', 0);
          } else if (stats.hunger < 20) {
            showCollectionFeedback('Hungry - Moving Slowly!', 'hunger', 0);
          } else if (stats.mood < 20) {
            showCollectionFeedback('Sad - Moving Slowly!', 'mood', 0);
          }
        }
        
        const currentSpeed = baseSpeed * speedMultiplier;
        
        // Store old position for collision detection
        const oldPlayerX = player.worldX;
        const oldPlayerY = player.worldY;
        
        // Try to move (only if not sleeping) - arrow keys only
        if (!player.sleeping) {
          const oldX = player.worldX;
          const oldY = player.worldY;
          
          if (keys["ArrowUp"]) player.worldY -= currentSpeed;
          if (keys["ArrowDown"]) player.worldY += currentSpeed;
          if (keys["ArrowLeft"]) player.worldX -= currentSpeed;
          if (keys["ArrowRight"]) player.worldX += currentSpeed;
          
          // Calculate movement distance for energy drain
          const distanceMoved = Math.sqrt(
            Math.pow(player.worldX - oldX, 2) + Math.pow(player.worldY - oldY, 2)
          );
          
          // Drain energy based on movement distance (only in playa mode, not in camp)
          if (distanceMoved > 0 && currentWorld === 'playa') {
            let energyMultiplier = 0.2; // Base 20% of current drain
            if (ridingBike) {
              energyMultiplier = 0.02; // Only 2% energy drain when riding bike (10x less)
            }
            const energyDrain = (distanceMoved / 10) * energyMultiplier;
            player.stats.energy = Math.max(0, player.stats.energy - energyDrain);
          }
          
          // Check boundaries based on current world
          if (currentWorld === 'camp') {
            // Camp boundaries - small rectangular area
            const campMinX = -400;
            const campMaxX = 400;
            const campMinY = -300;
            const campMaxY = 300;
            
            // Check if player has walked off the property
            if (player.worldX < campMinX || player.worldX + player.w > campMaxX ||
                player.worldY < campMinY || player.worldY + player.h > campMaxY) {
              // Player has walked off the property - exit camp
              exitCamp();
              return; // Exit the movement function
            }
          } else {
            // Playa boundaries and camp entry detection
          const playerCenterX = player.worldX + player.w / 2;
          const playerCenterY = player.worldY + player.h / 2;
            
            // Check if player has walked onto camp area
            const campMinX = -400;
            const campMaxX = 400;
            const campMinY = -300;
            const campMaxY = 300;
            
            if (player.worldX >= campMinX && player.worldX + player.w <= campMaxX &&
                player.worldY >= campMinY && player.worldY + player.h <= campMaxY) {
              // Check 5-second cooldown before allowing re-entry
              const timeSinceExit = Date.now() - campExitTime;
              const cooldownMs = 5000; // 5 seconds
              
              if (timeSinceExit < cooldownMs) {
                return; // Don't enter camp yet
              }
              
              // Player has walked onto camp area - enter camp
              enterCamp();
              return; // Exit the movement function
            }
          const distanceFromCenter = Math.sqrt(playerCenterX * playerCenterX + playerCenterY * playerCenterY);
          
          if (distanceFromCenter > TRASH_FENCE_RADIUS - 20) {
            // Push player back inside the fence
            const maxDistance = TRASH_FENCE_RADIUS - 20;
            const angle = Math.atan2(playerCenterY, playerCenterX);
            player.worldX = Math.cos(angle) * maxDistance - player.w / 2;
            player.worldY = Math.sin(angle) * maxDistance - player.h / 2;
            }
          }
          
          // Debug movement when riding bike
        }
        
        // Check collision with art cars
        artCars.forEach(car => {
          if (car !== ridingArtCar) { // Don't collide with the car you're riding
            if (player.worldX < car.x + car.w && 
                player.worldX + player.w > car.x &&
                player.worldY < car.y + car.h && 
                player.worldY + player.h > car.y) {
              
              // Check if player has gas cans to deliver
              if (player.inventory['Gas Can'] && player.inventory['Gas Can'] > 0) {
                // Deliver gas to art car
                if (!car.fuel) car.fuel = 0;
                car.fuel += 25; // Each gas can adds 25 fuel
                car.fuel = Math.min(car.fuel, 100); // Cap at 100
                
                // Remove gas can from inventory
                player.inventory['Gas Can']--;
                if (player.inventory['Gas Can'] === 0) {
                  delete player.inventory['Gas Can'];
                }
                
                // Give karma reward
                player.stats.karma += 20;
                player.stats.karma = Math.min(player.stats.karma, 9999);
                
                showCollectionFeedback(`Delivered gas to ${car.name}! +20 Karma`, 'mood', 0);
                updateStatsDisplay();
                updateInventoryDisplay();
              } else {
              // Collision detected - revert movement
              player.worldX = oldPlayerX;
              player.worldY = oldPlayerY;
              }
            }
          }
        });
        
        // Update transport buttons when player moves
        updateTransportButtons();
      } else if (ridingArtCar) {
        // When riding art car, allow movement on the car platform (only if not sleeping) - arrow keys only
        if (ridingArtCar.playerOffset && !player.sleeping) {
          if (keys["ArrowUp"]) ridingArtCar.playerOffset.y -= player.speed;
          if (keys["ArrowDown"]) ridingArtCar.playerOffset.y += player.speed;
          if (keys["ArrowLeft"]) ridingArtCar.playerOffset.x -= player.speed;
          if (keys["ArrowRight"]) ridingArtCar.playerOffset.x += player.speed;
        }
      }

      // Update camera to keep player centered
      camera.x = player.worldX - player.screenX;
      camera.y = player.worldY - player.screenY;
      
      // Generate new world content as player explores
      generateWorldContent();
      
      // Update art cars
      updateBikes();
      updateArtCars();
      updateNPCs();
      
      // Check coin collection (using world coordinates)
      coins.forEach(coin => {
        if (!coin.collected && 
            player.worldX < coin.x + coin.w && 
            player.worldX + player.w > coin.x &&
            player.worldY < coin.y + coin.h && 
            player.worldY + player.h > coin.y) {
          coin.collected = true;
          player.stats.coin += 1;
          updateStatsDisplay();
          showCombinedPickup('coin', 1);
        }
      });
      
      // Check MOOP collection
      moop.forEach(item => {
        if (!item.collected && 
            player.worldX < item.x + item.w && 
            player.worldX + player.w > item.x &&
            player.worldY < item.y + item.h && 
            player.worldY + player.h > item.y) {
          item.collected = true;
          
          if (item.inventoryItem) {
            // Add to inventory instead of giving karma
            invPush(item.type);
            showCollectionFeedback(`+${item.type}`, 'inventory', 0); // Show collection as inventory item
          } else {
            // Give karma immediately for non-inventory items
            applyEff(function(s) { s.karma += item.karmaValue; });
            updateStatsDisplay();
            showCollectionFeedback(`+${item.type}`, 'karma', item.karmaValue);
          }
        }
      });
      
      // Check drug collection
      drugs.forEach(drug => {
        if (!drug.collected && 
            player.worldX < drug.x + drug.w && 
            player.worldX + player.w > drug.x &&
            player.worldY < drug.y + drug.h && 
            player.worldY + player.h > drug.y) {
          drug.collected = true;
          
          // Apply immediate stat boosts if the drug has them
          if (drug.moodBoost) {
            player.stats.mood = Math.min(100, player.stats.mood + drug.moodBoost);
          }
          if (drug.energyBoost) {
            player.stats.energy = Math.min(100, player.stats.energy + drug.energyBoost);
          }
          
          // Handle special time effects
          if (drug.timeMultiplier === 0) {
            // Whip Its - stop time for 5 seconds and increment counter for vinetting
            player.drugEffects.timeStopDuration = 5;
            if (drug.type === 'Whip Its') {
              player.drugEffects.whipitsCount++;
            }
          }
          
          // Add drug to active drugs array
          const drugToAdd = {
            name: drug.type,
            emoji: drug.emoji, // Store the drug's emoji
            speedMultiplier: drug.speedMultiplier,
            hallucinating: drug.hallucinating,
            duration: drug.duration,
            startTime: Date.now(),
            mysteryType: drug.mysteryType, // Include mystery type for display
            timeMultiplier: drug.timeMultiplier,
            specialEffects: drug.specialEffects // Include special effects
          };
          
          player.drugEffects.activeDrugs.push(drugToAdd);
          
          // Track drug consumption for trip report
          player.tripStats.totalDrugsConsumed++;
          player.tripStats.drugsTried.add(drug.type);
          
          updateDrugEffectsDisplay();
          updateStatsDisplay();
          
          // Show mystery name when picking up, but reveal actual type when consumed
          const displayName = drug.type.includes('Mystery') ? drug.type : drug.type;
          showCollectionFeedback(`+${displayName}`, 'drug', drug.speedMultiplier);
          
          // Show special time effect notification if applicable
          if (drug.timeMultiplier !== undefined && drug.timeMultiplier !== 1) {
            let timeEffectText = '';
            if (drug.timeMultiplier === 0) {
              timeEffectText = '⏸️ TIME STOPPED!';
            } else if (drug.timeMultiplier > 1) {
              timeEffectText = `⏩ TIME SPEED: ${drug.timeMultiplier}x`;
            } else {
              timeEffectText = `⏪ TIME SLOW: ${drug.timeMultiplier}x`;
            }
            
            // Show time effect notification after a short delay
            setTimeout(() => {
              showCollectionFeedback(timeEffectText, 'time-effect', 0);
            }, 500);
          }
        }
      });
      
      // Check water bottle collection
      waterBottles.forEach(bottle => {
        if (!bottle.collected && 
            player.worldX < bottle.x + bottle.w && 
            player.worldX + player.w > bottle.x &&
            player.worldY < bottle.y + bottle.h && 
            player.worldY + player.h > bottle.y) {
          bottle.collected = true;
          invPush('Water');
          showCombinedPickup('water', 1);
        }
      });
      
      // Check snack collection
      snacks.forEach(snack => {
        if (!snack.collected && 
            player.worldX < snack.x + snack.w && 
            player.worldX + player.w > snack.x &&
            player.worldY < snack.y + snack.h && 
            player.worldY + player.h > snack.y) {
          snack.collected = true;
          // Use the specific food name instead of generic 'Snack'
          invPush(snack.name || 'Snack');
          showCollectionFeedback(`+${snack.name || 'Snack'}`, 'food', snack.hunger);
        }
      });
      
      // Check gasoline tank collection
      gasolineTanks.forEach(tank => {
        if (!tank.collected && 
            player.worldX < tank.x + tank.w && 
            player.worldX + player.w > tank.x &&
            player.worldY < tank.y + tank.h && 
            player.worldY + player.h > tank.y) {
          tank.collected = true;
          invPush('Gasoline Tank');
          showCollectionFeedback(`+Gasoline Tank (${tank.fuelAmount} fuel)`, 'karma', 5);
        }
      });
      
      // Stat decay over time
      const now = Date.now();
      if (now - lastStatDecay > statDecayInterval) {
        player.stats.thirst = Math.max(0, player.stats.thirst - 2);
        player.stats.hunger = Math.max(0, player.stats.hunger - 1.5);
        // Energy now drains based on movement, not time
        
        // Enhanced mood system for real-time decay
        let realtimeMoodChange = -0.5; // Base mood decay
        
        // Thirst heavily impacts mood
        if (player.stats.thirst <= 10) realtimeMoodChange -= 2; // Very dehydrated
        else if (player.stats.thirst <= 25) realtimeMoodChange -= 1; // Dehydrated
        else if (player.stats.thirst <= 40) realtimeMoodChange -= 0.5; // Thirsty
        
        // Energy heavily impacts mood
        if (player.stats.energy <= 5) realtimeMoodChange -= 3; // Exhausted
        else if (player.stats.energy <= 15) realtimeMoodChange -= 2; // Very tired
        else if (player.stats.energy <= 30) realtimeMoodChange -= 1; // Tired
        
        // Hunger impacts mood
        if (player.stats.hunger <= 20) realtimeMoodChange -= 1; // Hungry
        else if (player.stats.hunger <= 40) realtimeMoodChange -= 0.3; // Slightly hungry
        
        // Sleep deprivation
        if (!player.sleeping && player.stats.energy <= 20) {
          realtimeMoodChange -= 0.5; // Need sleep
        }
        
        player.stats.mood = Math.max(0, player.stats.mood + realtimeMoodChange);
        
        // Karma can go up or down based on other stats
        if (player.stats.thirst < 10 || player.stats.hunger < 10) {
          player.stats.karma = Math.max(0, player.stats.karma - 0.1); // Much slower decay rate
        }
        
        lastStatDecay = now;
        updateStatsDisplay();
      }
      
      // Update drug effects (duration is now in hours, decrement every hour)
      // This will be handled by the time system, not frame-by-frame
      
      // Process continuous drug effects (like Molly's mood/energy boost)
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.specialEffects === 'molly') {
          // Molly continuously boosts mood and energy
          player.stats.mood = Math.min(100, player.stats.mood + 0.5);
          player.stats.energy = Math.min(100, player.stats.energy + 0.3);
          
          // Generate hearts overlay effect
          if (Math.random() < 0.3) { // 30% chance each frame to spawn a heart
            mollyHearts.push({
              x: Math.random() * canvas.width,
              y: canvas.height + 20,
              vx: (Math.random() - 0.5) * 2,
              vy: -2 - Math.random() * 2,
              life: 60 + Math.random() * 40, // 60-100 frames
              size: 10 + Math.random() * 15, // 10-25 pixels
              opacity: 0.6 + Math.random() * 0.4 // 0.6-1.0 opacity
            });
          }
        }
      });
      
      // Update hearts animation
      mollyHearts = mollyHearts.filter(heart => {
        heart.x += heart.vx;
        heart.y += heart.vy;
        heart.life--;
        heart.opacity = Math.max(0, heart.opacity - 0.01);
        return heart.life > 0 && heart.opacity > 0;
      });
      
      // Update confetti animation
      updateConfetti();
      
      // Update display every frame to show countdown
      updateDrugEffectsDisplay();
      
      // Check for special location interactions
      checkSpecialLocationInteractions();
      
      // Update cooldown timers every second
      updateCooldownTimers();
      
      // Update day/night cycle
      updateDayNightCycle();
      
      // Update time display every frame for smooth animation
      updateTimeDisplay();
    }
    
    function checkSpecialLocationInteractions() {
      let playerInLocation = false;
      
      // Check dance floor collision
      danceFloors.forEach(location => {
        if (player.worldX < location.x + location.w && 
            player.worldX + player.w > location.x &&
            player.worldY < location.y + location.h && 
            player.worldY + player.h > location.y) {
          // Player is on dance floor - auto-trigger dance if not on cooldown
          if (player.cooldowns.dance === 0) {
            actions.dance();
          } else {
            showLocationAction('dance', location.name);
          }
          playerInLocation = true;
        }
      });
      
      // Check decorative block collision for climbing
      decorations.forEach(decoration => {
        if (player.worldX < decoration.x + decoration.w && 
            player.worldX + player.w > decoration.x &&
            player.worldY < decoration.y + decoration.h && 
            player.worldY + player.h > decoration.y) {
          // Player is at a decorative block - show climb action
          showLocationAction('climb', 'Decorative Block');
          playerInLocation = true;
        }
      });
      
      // Check orgy dome collision
      orgyDomes.forEach(location => {
        if (player.worldX < location.x + location.w && 
            player.worldX + player.w > location.x &&
            player.worldY < location.y + location.h && 
            player.worldY + player.h > location.y) {
          // Player is at orgy dome - auto-trigger orgy if not on cooldown
          if (player.cooldowns.orgy === 0) {
            actions.orgy();
          } else {
          showLocationAction('orgy', location.name);
          }
          playerInLocation = true;
        }
      });
      
      // Check home camp collision (only for player's actual home base)
      homeCamps.forEach((location, index) => {
        if (location.chunkId === 'player-home' && // Only check player's actual home base
            player.worldX < location.x + location.w && 
            player.worldX + player.w > location.x &&
            player.worldY < location.y + location.h && 
            player.worldY + player.h > location.y) {
          // Check 5-second cooldown before allowing re-entry
          const timeSinceExit = Date.now() - campExitTime;
          const cooldownMs = 5000; // 5 seconds
          
          if (timeSinceExit < cooldownMs) {
            return; // Don't enter camp yet - still in cooldown
          }
          
          // Player is at home camp - enter camp instead of showing chore button
          enterCamp();
          return; // Exit the function
        }
      });
      
      // Check center camp collision
      centerCamps.forEach(location => {
        if (player.worldX < location.x + location.w && 
            player.worldX + player.w > location.x &&
            player.worldY < location.y + location.h && 
            player.worldY + player.h > location.y) {
          // Player is at center camp - auto-trigger shopping if not on cooldown
          if (player.cooldowns.shop === 0) {
            actions.shop();
          } else {
          showLocationAction('shop', location.name);
          }
          playerInLocation = true;
        }
      });
      
      // Check fuel station collision
      fuelStations.forEach(location => {
        if (player.worldX < location.x + location.w && 
            player.worldX + player.w > location.x &&
            player.worldY < location.y + location.h && 
            player.worldY + player.h > location.y) {
          // Player is at fuel station - show buy gas action
          showLocationAction('buyGas', location.name);
          playerInLocation = true;
        }
      });
      
      // Hide location actions if player is not in any location
      if (!playerInLocation) {
        hideLocationActions();
      }
    }
    
    function showLocationAction(actionType, locationName) {
      const locationActions = document.getElementById('location-actions');
      const locationActionBtn = document.getElementById('location-action-btn');
      
      if (locationActions && locationActionBtn) {
        // Check cooldown for specific actions
        let cooldownText = '';
        if (actionType === 'chore') {
          const timeSinceLastChore = Date.now() - player.lastActionTimes.chore;
          const choreCooldown = 60000; // 60 seconds
          const remainingTime = Math.max(0, choreCooldown - timeSinceLastChore);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            cooldownText = ` (${remainingSeconds}s)`;
          }
        } else if (actionType === 'shop') {
          const timeSinceLastShop = Date.now() - player.lastActionTimes.shop;
          const shopCooldown = 60000; // 60 seconds
          const remainingTime = Math.max(0, shopCooldown - timeSinceLastShop);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            cooldownText = ` (${remainingSeconds}s)`;
          }
        } else if (actionType === 'climb') {
          const timeSinceLastClimb = Date.now() - player.lastActionTimes.climb;
          const climbCooldown = 20000; // 20 seconds
          const remainingTime = Math.max(0, climbCooldown - timeSinceLastClimb);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            cooldownText = ` (${remainingSeconds}s)`;
          }
        }
        
        // Set the button text and action with hotkey labels
        const actionTexts = {
          'dance': '💃 Dance Here [D]',
          'orgy': '🏕️ Join Orgy [O]',
          'chore': '🏠 Do Chores [H]',
          'shop': '🏛️ Shop at Center Camp [B]',
          'climb': '🧱 Climb Block [C]'
        };
        
        locationActionBtn.textContent = (actionTexts[actionType] || 'Action') + cooldownText;
        locationActionBtn.setAttribute('data-action', actionType);
        
        // Ensure the button has proper click handling
        locationActionBtn.onclick = function() {
          const action = this.getAttribute('data-action');
          if (action && actions[action]) {
            // Check cooldown for specific actions
            if (action === 'chore') {
              const timeSinceLastChore = Date.now() - player.lastActionTimes.chore;
              const choreCooldown = 60000; // 60 seconds
              if (timeSinceLastChore < choreCooldown) {
                const remainingSeconds = Math.ceil((choreCooldown - timeSinceLastChore) / 1000);
                showCollectionFeedback(`Chores on cooldown for ${remainingSeconds}s`, 'mood', 0);
                return;
              }
            } else if (action === 'shop') {
              const timeSinceLastShop = Date.now() - player.lastActionTimes.shop;
              const shopCooldown = 60000; // 60 seconds
              if (timeSinceLastShop < shopCooldown) {
                const remainingSeconds = Math.ceil((shopCooldown - timeSinceLastShop) / 1000);
                showCollectionFeedback(`Shopping on cooldown for ${remainingSeconds}s`, 'mood', 0);
                return;
              }
            } else if (action === 'climb') {
              const timeSinceLastClimb = Date.now() - player.lastActionTimes.climb;
              const climbCooldown = 20000; // 20 seconds
              if (timeSinceLastClimb < climbCooldown) {
                const remainingSeconds = Math.ceil((climbCooldown - timeSinceLastClimb) / 1000);
                showCollectionFeedback(`Climbing on cooldown for ${remainingSeconds}s`, 'mood', 0);
                return;
              }
            }
            actions[action]();
          }
        };
        
        // Show the location actions
        locationActions.style.display = 'block';
        
        // Debug log removed for cleaner console
      }
    }
    
    function hideLocationActions() {
      const locationActions = document.getElementById('location-actions');
      if (locationActions) {
        locationActions.style.display = 'none';
      }
      
      // Close all open modals when leaving location
      const modals = document.querySelectorAll('.encounter-modal');
      modals.forEach(modal => {
        document.body.removeChild(modal);
      });
      openModals.clear();
    }
    
    // Update cooldown timers for location actions
    function updateCooldownTimers() {
      const locationActions = document.getElementById('location-actions');
      const locationActionBtn = document.getElementById('location-action-btn');
      
      if (locationActions && locationActionBtn && locationActions.style.display !== 'none') {
        const actionType = locationActionBtn.getAttribute('data-action');
        
        if (actionType === 'chore') {
          const timeSinceLastChore = Date.now() - player.lastActionTimes.chore;
          const choreCooldown = 60000; // 60 seconds
          const remainingTime = Math.max(0, choreCooldown - timeSinceLastChore);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            const baseText = '🏠 Do Chores [H]';
            locationActionBtn.textContent = `${baseText} (${remainingSeconds}s)`;
          } else {
            locationActionBtn.textContent = '🏠 Do Chores [H]';
          }
        } else if (actionType === 'shop') {
          const timeSinceLastShop = Date.now() - player.lastActionTimes.shop;
          const shopCooldown = 60000; // 60 seconds
          const remainingTime = Math.max(0, shopCooldown - timeSinceLastShop);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            const baseText = '🏛️ Shop at Center Camp [B]';
            locationActionBtn.textContent = `${baseText} (${remainingSeconds}s)`;
          } else {
            locationActionBtn.textContent = '🏛️ Shop at Center Camp [B]';
          }
        } else if (actionType === 'climb') {
          const timeSinceLastClimb = Date.now() - player.lastActionTimes.climb;
          const climbCooldown = 20000; // 20 seconds
          const remainingTime = Math.max(0, climbCooldown - timeSinceLastClimb);
          
          if (remainingTime > 0) {
            const remainingSeconds = Math.ceil(remainingTime / 1000);
            const baseText = '🧱 Climb Block [C]';
            locationActionBtn.textContent = `${baseText} (${remainingSeconds}s)`;
          } else {
            locationActionBtn.textContent = '🧱 Climb Block [C]';
          }
        }
      }
    }

    function drawWombat(x, y, w, h) {
      // Player is always drawn at screen center
      const screenX = player.screenX;
      const screenY = player.screenY;
      
      // Draw wombat body (rounded rectangle)
      ctx.fillStyle = player.color;
      ctx.fillRect(screenX, screenY, w, h);
      
      // Draw wombat face
      ctx.fillStyle = "#fff";
      if (player.sleeping) {
        // Draw X eyes when sleeping
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        
        // Left eye X
        ctx.beginPath();
        ctx.moveTo(screenX + 8, screenY + 8);
        ctx.lineTo(screenX + 14, screenY + 14);
        ctx.moveTo(screenX + 14, screenY + 8);
        ctx.lineTo(screenX + 8, screenY + 14);
        ctx.stroke();
        
        // Right eye X
        ctx.beginPath();
        ctx.moveTo(screenX + 18, screenY + 8);
        ctx.lineTo(screenX + 24, screenY + 14);
        ctx.moveTo(screenX + 24, screenY + 8);
        ctx.lineTo(screenX + 18, screenY + 14);
        ctx.stroke();
      } else {
        // Draw open eyes when awake
        ctx.fillRect(screenX + 8, screenY + 8, 6, 6); // eye
        ctx.fillRect(screenX + 18, screenY + 8, 6, 6); // eye
      }
      
      // Draw nose
      ctx.fillStyle = "#000";
      ctx.fillRect(screenX + 14, screenY + 16, 4, 4);
      
      // Draw ears
      ctx.fillStyle = player.color;
      ctx.fillRect(screenX - 2, screenY - 2, 8, 8);
      ctx.fillRect(screenX + w - 6, screenY - 2, 8, 8);
    }

    function drawDecorations() {
      decorations.forEach(decoration => {
        const screenX = decoration.x - camera.x;
        const screenY = decoration.y - camera.y;
        
        // Only draw if on screen
        if (screenX > -decoration.w && screenX < canvas.width && 
            screenY > -decoration.h && screenY < canvas.height) {
          ctx.fillStyle = decoration.color;
          ctx.fillRect(screenX, screenY, decoration.w, decoration.h);
          
          // Add some sparkle effect
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.fillRect(screenX + decoration.w/2 - 1, screenY + decoration.h/2 - 1, 2, 2);
        }
      });
    }
    
    function drawCoins() {
      coins.forEach(coin => {
        if (!coin.collected) {
          const screenX = coin.x - camera.x;
          const screenY = coin.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -coin.w && screenX < canvas.width && 
              screenY > -coin.h && screenY < canvas.height) {
            ctx.fillStyle = "#ffd700";
            ctx.fillRect(screenX, screenY, coin.w, coin.h);
            
            // Add sparkle effect
            ctx.fillStyle = "#fff";
            ctx.fillRect(screenX + coin.w/2 - 1, screenY + coin.h/2 - 1, 2, 2);
          }
        }
      });
    }
    
    function drawWaterBottles() {
      waterBottles.forEach(bottle => {
        if (!bottle.collected) {
          const screenX = bottle.x - camera.x;
          const screenY = bottle.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -bottle.w && screenX < canvas.width && 
              screenY > -bottle.h && screenY < canvas.height) {
            // Draw water bottle (blue rectangle with cap)
            ctx.fillStyle = "#00bfff";
            ctx.fillRect(screenX, screenY + 2, bottle.w, bottle.h - 4);
            
            // Draw cap
            ctx.fillStyle = "#ff6b35";
            ctx.fillRect(screenX, screenY, bottle.w, 4);
            
            // Add sparkle
            ctx.fillStyle = "#fff";
            ctx.fillRect(screenX + bottle.w/2 - 1, screenY + bottle.h/2 - 1, 2, 2);
          }
        }
      });
    }
    
    function drawSnacks() {
      snacks.forEach(snack => {
        if (!snack.collected) {
          const screenX = snack.x - camera.x;
          const screenY = snack.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -snack.w && screenX < canvas.width && 
              screenY > -snack.h && screenY < canvas.height) {
            
            // Draw food background
            ctx.fillStyle = snack.color || "#8B4513";
            ctx.fillRect(screenX, screenY, snack.w, snack.h);
            
            // Add border
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.strokeRect(screenX, screenY, snack.w, snack.h);
            
            // Draw emoji
            ctx.font = "12px Arial";
            ctx.fillStyle = "#000";
            ctx.textAlign = "center";
            ctx.fillText(snack.emoji || "🍎", screenX + snack.w/2, screenY + snack.h/2 + 4);
            
            // Add sparkle
            ctx.fillStyle = "#fff";
            ctx.fillRect(screenX + snack.w - 4, screenY + 2, 2, 2);
          }
        }
      });
    }
    
    function drawBikes() {
      bikes.forEach(bike => {
        if (!bike.collected) {
          const screenX = bike.x - camera.x;
          const screenY = bike.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -bike.w && screenX < canvas.width && 
              screenY > -bike.h && screenY < canvas.height) {
            
            // Draw bike emoji (2x larger)
            ctx.font = '44px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('🚲', screenX + bike.w/2, screenY + bike.h/2 + 16);
            
            // Boarding instructions now handled by buttons
            
            // Show riding indicator if player is on this bike
            if (ridingBike === bike) {
              ctx.fillStyle = "#ffd700";
              ctx.fillRect(screenX + bike.w/2 - 4, screenY + bike.h + 10, 8, 8);
              // Dismount instructions now handled by buttons
            }
          }
        }
      });
    }
    
    function drawMoop() {
      moop.forEach(item => {
        if (!item.collected) {
          const screenX = item.x - camera.x;
          const screenY = item.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -item.w && screenX < canvas.width && 
              screenY > -item.h && screenY < canvas.height) {
            
            // Draw MOOP item with emoji
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.emoji, screenX + item.w/2, screenY + item.h/2 + 4);
          }
        }
      });
    }
    
    function drawDrugs() {
      drugs.forEach(drug => {
        if (!drug.collected) {
          const screenX = drug.x - camera.x;
          const screenY = drug.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -drug.w && screenX < canvas.width && 
              screenY > -drug.h && screenY < canvas.height) {
            
            // Create pulsing and glowing effect
            const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 1;
            const glowIntensity = Math.sin(Date.now() * 0.008) * 0.5 + 0.5;
            
            // Draw glow effect (multiple layers for intensity)
            ctx.save();
            ctx.shadowColor = '#8a2be2';
            ctx.shadowBlur = 15 + glowIntensity * 10;
            
            // Draw outer glow ring
            ctx.beginPath();
            ctx.arc(screenX + drug.w/2, screenY + drug.h/2, 15 + pulse * 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(138, 43, 226, ${0.1 + glowIntensity * 0.1})`;
            ctx.fill();
            
            // Draw inner glow
            ctx.beginPath();
            ctx.arc(screenX + drug.w/2, screenY + drug.h/2, 8 + pulse * 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(138, 43, 226, ${0.2 + glowIntensity * 0.2})`;
            ctx.fill();
            
            // Draw drug emoji with larger size and glow
            ctx.font = `${20 * pulse}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(drug.emoji, screenX + drug.w/2, screenY + drug.h/2 + 6);
            
            ctx.restore();
          }
        }
      });
    }

    function drawSpecialLocations() {
      // Draw dance floors
      danceFloors.forEach(location => {
        const screenX = location.x - camera.x;
        const screenY = location.y - camera.y;
        
        if (screenX > -location.w && screenX < canvas.width && 
            screenY > -location.h && screenY < canvas.height) {
          
          // Draw dance floor with pulsing effect
          const pulse = Math.sin(Date.now() * 0.008) * 0.1 + 1;
          ctx.fillStyle = `rgba(255, 20, 147, ${0.3 * pulse})`;
          ctx.fillRect(screenX, screenY, location.w, location.h);
          
          // Draw emoji in center
          ctx.font = `${24 * pulse}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(location.emoji, screenX + location.w/2, screenY + location.h/2 + 8);
          
          // Draw name label
          ctx.font = '12px Arial';
          ctx.fillStyle = '#fff';
          ctx.fillText(location.name, screenX + location.w/2, screenY + location.h + 15);
        }
      });
      
      // Draw art installations
      artInstallations.forEach(location => {
        const screenX = location.x - camera.x;
        const screenY = location.y - camera.y;
        
        if (screenX > -location.w && screenX < canvas.width && 
            screenY > -location.h && screenY < canvas.height) {
          
          // Draw art installation
          ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
          ctx.fillRect(screenX, screenY, location.w, location.h);
          
          // Draw emoji in center
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(location.emoji, screenX + location.w/2, screenY + location.h/2 + 6);
          
          // Draw name label
          ctx.font = '12px Arial';
          ctx.fillStyle = '#fff';
          ctx.fillText(location.name, screenX + location.w/2, screenY + location.h + 15);
        }
      });
      
      // Draw orgy domes
      orgyDomes.forEach(location => {
        const screenX = location.x - camera.x;
        const screenY = location.y - camera.y;
        
        if (screenX > -location.w && screenX < canvas.width && 
            screenY > -location.h && screenY < canvas.height) {
          
          // Draw orgy dome with subtle glow
          ctx.fillStyle = 'rgba(138, 43, 226, 0.3)';
          ctx.fillRect(screenX, screenY, location.w, location.h);
          
          // Draw emoji in center
          ctx.font = '22px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(location.emoji, screenX + location.w/2, screenY + location.h/2 + 7);
          
          // Draw name label
          ctx.font = '12px Arial';
          ctx.fillStyle = '#fff';
          ctx.fillText(location.name, screenX + location.w/2, screenY + location.h + 15);
        }
      });
      
      // Draw home camps
      homeCamps.forEach(location => {
        const screenX = location.x - camera.x;
        const screenY = location.y - camera.y;
        
        if (screenX > -location.w && screenX < canvas.width && 
            screenY > -location.h && screenY < canvas.height) {
          
          // Draw camp ground
          ctx.fillStyle = 'rgba(160, 82, 45, 0.3)'; // Saddle brown for playa dust
          ctx.fillRect(screenX, screenY, location.w, location.h);
          
          // Draw multiple tents around the camp
          const tentColors = ['#ff6b35', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
          const tentPositions = [
            {x: screenX + 20, y: screenY + 20, size: 25},
            {x: screenX + location.w - 45, y: screenY + 15, size: 20},
            {x: screenX + 15, y: screenY + location.h - 45, size: 22},
            {x: screenX + location.w - 40, y: screenY + location.h - 40, size: 18},
            {x: screenX + location.w/2 - 15, y: screenY + 10, size: 20},
            {x: screenX + location.w/2 + 5, y: screenY + location.h - 30, size: 24}
          ];
          
          tentPositions.forEach((tent, i) => {
            // Draw tent base
            ctx.fillStyle = tentColors[i % tentColors.length];
            ctx.fillRect(tent.x, tent.y, tent.size, tent.size * 0.7);
            
            // Draw tent top (triangle)
            ctx.fillStyle = tentColors[i % tentColors.length];
            ctx.beginPath();
            ctx.moveTo(tent.x, tent.y);
            ctx.lineTo(tent.x + tent.size/2, tent.y - tent.size * 0.4);
            ctx.lineTo(tent.x + tent.size, tent.y);
            ctx.closePath();
            ctx.fill();
            
            // Draw tent door
            ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
            ctx.fillRect(tent.x + tent.size/2 - 3, tent.y + tent.size * 0.4, 6, tent.size * 0.3);
          });
          
          // Draw disco ball in center with pulsing effect
          const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
          const discoBallSize = 15 * pulse;
          const discoBallX = screenX + location.w/2;
          const discoBallY = screenY + location.h/2 - 10;
          
          // Disco ball glow
          ctx.save();
          ctx.globalAlpha = pulse * 0.5;
          const discoGradient = ctx.createRadialGradient(discoBallX, discoBallY, 0, discoBallX, discoBallY, discoBallSize * 2);
          discoGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
          discoGradient.addColorStop(0.5, 'rgba(255, 100, 255, 0.6)');
          discoGradient.addColorStop(1, 'rgba(100, 100, 255, 0.3)');
          ctx.fillStyle = discoGradient;
          ctx.fillRect(discoBallX - discoBallSize * 2, discoBallY - discoBallSize * 2, discoBallSize * 4, discoBallSize * 4);
          ctx.restore();
          
          // Disco ball itself
          ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
          ctx.beginPath();
          ctx.arc(discoBallX, discoBallY, discoBallSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Disco ball sparkles
          ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.8})`;
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + Date.now() * 0.003;
            const sparkleX = discoBallX + Math.cos(angle) * discoBallSize * 1.5;
            const sparkleY = discoBallY + Math.sin(angle) * discoBallSize * 1.5;
            ctx.fillRect(sparkleX - 1, sparkleY - 1, 2, 2);
          }
          
          // Draw camp fire in corner
          ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
          ctx.beginPath();
          ctx.arc(screenX + 15, screenY + location.h - 15, 8, 0, Math.PI * 2);
          ctx.fill();
          
          // Fire glow
          ctx.save();
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = 'rgba(255, 150, 0, 0.4)';
          ctx.beginPath();
          ctx.arc(screenX + 15, screenY + location.h - 15, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Draw name label with camp theme
          ctx.font = 'bold 12px Arial';
          ctx.fillStyle = '#ffd700';
          ctx.textAlign = 'center';
          ctx.fillText(location.name, screenX + location.w/2, screenY + location.h + 15);
        }
      });
      
      // Draw center camps
      centerCamps.forEach(location => {
        const screenX = location.x - camera.x;
        const screenY = location.y - camera.y;
        
        if (screenX > -location.w && screenX < canvas.width && 
            screenY > -location.h && screenY < canvas.height) {
          
          // Draw center camp with golden glow
          const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 1;
          ctx.fillStyle = `rgba(255, 215, 0, ${0.4 * pulse})`;
          ctx.fillRect(screenX, screenY, location.w, location.h);
          
          // Draw emoji in center
          ctx.font = `${22 * pulse}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(location.emoji, screenX + location.w/2, screenY + location.h/2 + 7);
          
          // Draw name label
          ctx.font = '12px Arial';
          ctx.fillStyle = '#fff';
          ctx.fillText(location.name, screenX + location.w/2, screenY + location.h + 15);
        }
      });
    }

    function drawArtCars() {
      artCars.forEach(car => {
        const screenX = car.x - camera.x;
        const screenY = car.y - camera.y;
        
        // Only draw if on screen
        if (screenX > -car.w && screenX < canvas.width && 
            screenY > -car.h && screenY < canvas.height) {
          
          // Draw art car body (platform) with design-specific styling
          ctx.fillStyle = car.color;
          ctx.fillRect(screenX, screenY, car.w, car.h);
          
          // Draw design-specific details
          switch(car.design) {
            case "bus":
              // Bus design - rectangular with windows
              ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
              for (let i = 0; i < 4; i++) {
                ctx.fillRect(screenX + 50 + i * (car.w - 100) / 4, screenY + 50, (car.w - 150) / 4, 60);
              }
              break;
            case "ship":
              // Ship design - curved bow
              ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
              ctx.beginPath();
              ctx.arc(screenX + car.w * 0.7, screenY + car.h/2, car.w * 0.3, 0, Math.PI, true);
              ctx.fill();
              break;
            case "whale":
              // Whale design - rounded and elongated
              ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
              ctx.beginPath();
              ctx.ellipse(screenX + car.w/2, screenY + car.h/2, car.w/2, car.h/2, 0, 0, 2 * Math.PI);
              ctx.fill();
              break;
            case "cat":
              // Cat design - triangular ears
              ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
              ctx.beginPath();
              ctx.moveTo(screenX + car.w/2, screenY + 30);
              ctx.lineTo(screenX + car.w/2 - 40, screenY + 80);
              ctx.lineTo(screenX + car.w/2 + 40, screenY + 80);
              ctx.closePath();
              ctx.fill();
              break;
            case "dragon":
              // Dragon design - spikes
              ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
              for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(screenX + 50 + i * (car.w - 100) / 4, screenY + 30);
                ctx.lineTo(screenX + 70 + i * (car.w - 100) / 4, screenY + 80);
                ctx.lineTo(screenX + 30 + i * (car.w - 100) / 4, screenY + 80);
                ctx.closePath();
                ctx.fill();
              }
              break;
            case "turtle":
              // Turtle design - hexagonal shell
              ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
              ctx.beginPath();
              ctx.moveTo(screenX + car.w/2, screenY + 50);
              ctx.lineTo(screenX + car.w - 50, screenY + car.h/2);
              ctx.lineTo(screenX + car.w/2, screenY + car.h - 50);
              ctx.lineTo(screenX + 50, screenY + car.h/2);
              ctx.closePath();
              ctx.fill();
              break;
            case "phoenix":
              // Phoenix design - flame patterns
              ctx.fillStyle = "rgba(255, 100, 0, 0.4)";
              for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(screenX + car.w/2 + (i-1) * 60, screenY + 100, 40, 0, Math.PI);
                ctx.fill();
              }
              break;
            case "octopus":
              // Octopus design - circular with tentacles
              ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
              ctx.beginPath();
              ctx.arc(screenX + car.w/2, screenY + car.h/2, car.w/3, 0, 2 * Math.PI);
              ctx.fill();
              // Tentacles
              for (let i = 0; i < 4; i++) {
                ctx.fillRect(screenX + car.w/2 - 20 + i * 40, screenY + car.h - 50, 20, 50);
              }
              break;
          }
          
          // Draw platform surface pattern
          ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
          for (let i = 0; i < car.w; i += 40) {
            ctx.fillRect(screenX + i, screenY, 2, car.h);
          }
          for (let i = 0; i < car.h; i += 20) {
            ctx.fillRect(screenX, screenY + i, car.w, 2);
          }
          
          // Add wheels (scaled to car size)
          const wheelSize = Math.min(car.w, car.h) / 8;
          ctx.fillStyle = "#333";
          ctx.fillRect(screenX + wheelSize, screenY - wheelSize/2, wheelSize * 2, wheelSize);
          ctx.fillRect(screenX + car.w - wheelSize * 3, screenY - wheelSize/2, wheelSize * 2, wheelSize);
          ctx.fillRect(screenX + wheelSize, screenY + car.h - wheelSize/2, wheelSize * 2, wheelSize);
          ctx.fillRect(screenX + car.w - wheelSize * 3, screenY + car.h - wheelSize/2, wheelSize * 2, wheelSize);
          
          // Add decorative elements
          ctx.fillStyle = "#ffd700";
          ctx.fillRect(screenX + 20, screenY + 20, 40, 40);
          ctx.fillRect(screenX + car.w - 60, screenY + 20, 40, 40);
          
          // Add sparkle effects
          ctx.fillStyle = "#fff";
          ctx.fillRect(screenX + car.w/2 - 10, screenY + car.h/2 - 10, 20, 20);
          ctx.fillRect(screenX + 150, screenY + 100, 10, 10);
          ctx.fillRect(screenX + car.w - 150, screenY + 100, 10, 10);
          
          // Boarding instructions now handled by buttons
          
          // Add lights at night
          const isNight = player.time.hour >= 18 || player.time.hour < 6;
          if (isNight) {
            // Add LED strip lights around the car
            ctx.fillStyle = "#00ffff"; // Cyan LED color
            ctx.fillRect(screenX, screenY - 5, car.w, 3); // Top
            ctx.fillRect(screenX, screenY + car.h + 2, car.w, 3); // Bottom
            ctx.fillRect(screenX - 5, screenY, 3, car.h); // Left
            ctx.fillRect(screenX + car.w + 2, screenY, 3, car.h); // Right
            
            // Add pulsing center light
            const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
            ctx.fillRect(screenX + car.w/2 - 15, screenY + car.h/2 - 15, 30, 30);
            
            // Add corner lights
            ctx.fillStyle = "#ff0000"; // Red corner lights
            ctx.fillRect(screenX + 10, screenY + 10, 8, 8);
            ctx.fillRect(screenX + car.w - 18, screenY + 10, 8, 8);
            ctx.fillRect(screenX + 10, screenY + car.h - 18, 8, 8);
            ctx.fillRect(screenX + car.w - 18, screenY + car.h - 18, 8, 8);
          }
          
          // Show riding indicator if player is riding this car
          if (ridingArtCar === car) {
            ctx.fillStyle = "#ffd700";
            ctx.fillRect(screenX + car.w/2 - 10, screenY + car.h + 10, 20, 20);
            // Draw car name
            ctx.fillStyle = "#fff";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(car.name, screenX + car.w/2, screenY + car.h + 45);
            // Dismount instructions now handled by buttons
          }
          
          // Draw flame effects based on fuel level
          if (car.fuel !== undefined && car.fuel > 0) {
            const fuelRatio = car.fuel / car.maxFuel;
            const flameIntensity = Math.max(0.1, fuelRatio); // Minimum 10% flame when any fuel
            
            // Draw flames behind the car
            ctx.save();
            ctx.globalAlpha = flameIntensity * 0.8;
            
            // Create flame gradient
            const flameGradient = ctx.createLinearGradient(
              screenX - 30, screenY + car.h/2,
              screenX + car.w + 30, screenY + car.h/2
            );
            flameGradient.addColorStop(0, 'rgba(255, 100, 0, 0)'); // Transparent at car
            flameGradient.addColorStop(0.3, 'rgba(255, 150, 0, 0.8)'); // Orange
            flameGradient.addColorStop(0.6, 'rgba(255, 50, 0, 0.6)'); // Red-orange
            flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0.4)'); // Red
            
            ctx.fillStyle = flameGradient;
            
            // Draw multiple flame layers for depth
            for (let i = 0; i < 3; i++) {
              const offset = i * 5;
              const height = 20 + i * 10;
              const width = car.w + 60 + i * 20;
              
              ctx.fillRect(
                screenX - 30 - i * 10, 
                screenY + car.h/2 - height/2 + offset, 
                width, 
                height
              );
            }
            
            // Add flickering flame particles
            if (Math.random() < flameIntensity * 0.5) {
              ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, ${flameIntensity})`;
              for (let i = 0; i < 5; i++) {
                const particleX = screenX + Math.random() * car.w;
                const particleY = screenY + car.h/2 + (Math.random() - 0.5) * 30;
                const particleSize = 2 + Math.random() * 3;
                
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            
            ctx.restore();
          }
        }
      });
    }
    
    function drawNPCs() {
      npcs.forEach(npc => {
        const screenX = npc.x - camera.x;
        const screenY = npc.y - camera.y;
        
        // Only draw if on screen
        if (screenX > -npc.w && screenX < canvas.width && 
            screenY > -npc.h && screenY < canvas.height) {
          
          // Check if this is a camp wombat (should look like player)
          if (npc.isWombat) {
            // Draw blocky wombat like the player
            ctx.fillStyle = npc.color || '#ff6b35';
            ctx.fillRect(screenX, screenY, npc.w, npc.h);
            
            // Draw eyes (white squares)
            ctx.fillStyle = '#fff';
            ctx.fillRect(screenX + 6, screenY + 6, 6, 6);
            ctx.fillRect(screenX + npc.w - 12, screenY + 6, 6, 6);
            
            // Draw eye pupils (black dots)
            ctx.fillStyle = '#000';
            ctx.fillRect(screenX + 8, screenY + 8, 2, 2);
            ctx.fillRect(screenX + npc.w - 10, screenY + 8, 2, 2);
          } else {
            // Draw regular NPC with emoji
          // Draw NPC background circle
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.beginPath();
          ctx.arc(screenX + npc.w/2, screenY + npc.h/2, npc.w/2, 0, 2 * Math.PI);
          ctx.fill();
          
          // Draw NPC emoji
          ctx.font = `${npc.w}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(npc.emoji, screenX + npc.w/2, screenY + npc.h/2);
          }
          
          // Add behavior-specific visual effects
          switch (npc.behavior) {
            case 'dance':
              // Add dancing sparkles
              if (Math.random() < 0.3) {
                ctx.fillStyle = `rgba(255, 215, 0, ${Math.random() * 0.8})`;
                ctx.fillRect(screenX + Math.random() * npc.w, screenY + Math.random() * npc.h, 2, 2);
              }
              break;
            case 'bike':
              // Add speed lines
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 1;
              for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(screenX - 10 - i * 5, screenY + npc.h/2);
                ctx.lineTo(screenX - 5 - i * 5, screenY + npc.h/2);
                ctx.stroke();
              }
              break;
            case 'artcar':
              // Add passenger indicator
              if (npc.targetArtCar) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.fillRect(screenX + npc.w/2 - 2, screenY - 8, 4, 4);
              }
              break;
          }
          
          // Draw gas can indicator if NPC has one
          if (npc.hasGasCan) {
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(screenX + npc.w - 8, screenY, 6, 8);
          }
        }
      });
    }
    
    function drawGasolineTanks() {
      gasolineTanks.forEach(tank => {
        if (!tank.collected) {
          const screenX = tank.x - camera.x;
          const screenY = tank.y - camera.y;
          
          // Only draw if on screen
          if (screenX > -tank.w && screenX < canvas.width && 
              screenY > -tank.h && screenY < canvas.height) {
            
            // Draw gasoline tank
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(screenX, screenY, tank.w, tank.h);
            
            // Add fuel indicator
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(screenX + 2, screenY + 2, tank.w - 4, 4);
            
            // Add flame symbol
            ctx.font = '12px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⛽', screenX + tank.w/2, screenY + tank.h/2 + 8);
          }
        }
      });
    }
    
    function updateStatsDisplay() {
      document.getElementById('thirst-bar').style.width = player.stats.thirst + '%';
      document.getElementById('thirst-value').textContent = Math.round(player.stats.thirst - 100);
      
      document.getElementById('hunger-bar').style.width = player.stats.hunger + '%';
      document.getElementById('hunger-value').textContent = Math.round(player.stats.hunger - 100);
      
      document.getElementById('energy-bar').style.width = player.stats.energy + '%';
      document.getElementById('energy-value').textContent = Math.round(player.stats.energy);
      
      // Add visual indicators for low stats (speed penalties)
      const energyBar = document.getElementById('energy-bar');
      const thirstBar = document.getElementById('thirst-bar');
      const hungerBar = document.getElementById('hunger-bar');
      const moodBar = document.getElementById('mood-bar');
      
      // Energy indicator
      if (player.stats.energy < 20) {
        energyBar.style.backgroundColor = '#ff4757';
        energyBar.style.boxShadow = '0 0 10px rgba(255, 71, 87, 0.5)';
      } else {
        energyBar.style.backgroundColor = '#2ed573';
        energyBar.style.boxShadow = 'none';
      }
      
      // Thirst indicator
      if (player.stats.thirst < 20) {
        thirstBar.style.backgroundColor = '#ff4757';
        thirstBar.style.boxShadow = '0 0 10px rgba(255, 71, 87, 0.5)';
      } else {
        thirstBar.style.backgroundColor = '#00bcd4';
        thirstBar.style.boxShadow = 'none';
      }
      
      // Hunger indicator
      if (player.stats.hunger < 20) {
        hungerBar.style.backgroundColor = '#ff4757';
        hungerBar.style.boxShadow = '0 0 10px rgba(255, 71, 87, 0.5)';
      } else {
        hungerBar.style.backgroundColor = '#ff9800';
        hungerBar.style.boxShadow = 'none';
      }
      
      // Enhanced mood indicator with more granular warnings
      if (player.stats.mood < 10) {
        moodBar.style.backgroundColor = '#ff0000'; // Critical - red
        moodBar.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.8)';
      } else if (player.stats.mood < 25) {
        moodBar.style.backgroundColor = '#ff4757'; // Very low - bright red
        moodBar.style.boxShadow = '0 0 12px rgba(255, 71, 87, 0.6)';
      } else if (player.stats.mood < 40) {
        moodBar.style.backgroundColor = '#ff6b35'; // Low - orange-red
        moodBar.style.boxShadow = '0 0 8px rgba(255, 107, 53, 0.4)';
      } else if (player.stats.mood < 60) {
        moodBar.style.backgroundColor = '#ffa502'; // Medium - orange
        moodBar.style.boxShadow = '0 0 5px rgba(255, 165, 2, 0.3)';
      } else {
        moodBar.style.backgroundColor = '#e91e63'; // Good - normal purple
        moodBar.style.boxShadow = 'none';
      }
      
      document.getElementById('mood-bar').style.width = player.stats.mood + '%';
      document.getElementById('mood-value').textContent = Math.round(player.stats.mood);
      
      document.getElementById('karma-amount').textContent = Math.round(player.stats.karma);
      
      document.getElementById('coin-amount').textContent = player.stats.coin;
      
      // Calculate and display current speed multiplier (includes bike, drugs, and stats)
      let totalSpeedMultiplier = 1;
      
      // Add bike speed multiplier if riding a bike
      if (ridingBike) {
        totalSpeedMultiplier *= 1.5;
      }
      
      // Add drug speed multipliers
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.speedMultiplier !== undefined && !isNaN(drug.speedMultiplier)) {
          totalSpeedMultiplier *= drug.speedMultiplier;
        }
      });
      
      // Add stat-based speed multipliers (same calculation as in movement)
      const stats = player.stats;
      
      // Energy multiplier (0.3x to 1.2x based on energy level)
      const energyMultiplier = 0.3 + (stats.energy / 100) * 0.9;
      
      // Thirst multiplier (0.4x to 1.1x based on thirst level)
      const thirstMultiplier = 0.4 + (stats.thirst / 100) * 0.7;
      
      // Hunger multiplier (0.5x to 1.1x based on hunger level)
      const hungerMultiplier = 0.5 + (stats.hunger / 100) * 0.6;
      
      // Mood multiplier (0.6x to 1.2x based on mood level)
      const moodMultiplier = 0.6 + (stats.mood / 100) * 0.6;
      
      // Apply all stat multipliers
      totalSpeedMultiplier *= energyMultiplier * thirstMultiplier * hungerMultiplier * moodMultiplier;
      
      // Calculate stats-only speed multiplier for display
      const statsSpeedMultiplier = energyMultiplier * thirstMultiplier * hungerMultiplier * moodMultiplier;
      
      // Update stats speed display
      const statsSpeedDisplay = document.getElementById('stats-speed-display');
      if (statsSpeedDisplay) {
        let statsIcon = '📊';
        let statsColor = '#ffffff';
        
        if (statsSpeedMultiplier < 0.5) {
          statsIcon = '🐌';
          statsColor = '#ff4757';
        } else if (statsSpeedMultiplier < 0.8) {
          statsIcon = '😴';
          statsColor = '#ff6b35';
        } else if (statsSpeedMultiplier > 1.0) {
          statsIcon = '💪';
          statsColor = '#00ff88';
        }
        
        statsSpeedDisplay.innerHTML = `${statsIcon} <span style="color: ${statsColor};">${statsSpeedMultiplier.toFixed(2)}x</span>`;
      }
      
      // Calculate and display current time perception multiplier
      let totalTimeMultiplier = 1;
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.timeMultiplier !== undefined && !isNaN(drug.timeMultiplier) && drug.timeMultiplier !== 0) {
          totalTimeMultiplier *= drug.timeMultiplier;
        }
      });
      
      // Handle time stop (Whip Its effect)
      if (player.drugEffects.timeStopDuration > 0) {
        totalTimeMultiplier = 0; // Time is stopped
      }
      
      // Update speed display
      const speedDisplay = document.getElementById('speed-display');
      if (speedDisplay) {
        const speedColor = totalSpeedMultiplier > 1 ? '#00ff88' : (totalSpeedMultiplier < 1 ? '#ff6b35' : '#ffffff');
        speedDisplay.innerHTML = `<span style="color: ${speedColor};">${totalSpeedMultiplier.toFixed(1)}x</span>`;
      }
      
      // Update time perception display
      const timeDisplay = document.getElementById('time-perception-display');
      if (timeDisplay) {
        let timeColor = '#ffffff';
        
        if (totalTimeMultiplier === 0) {
          timeColor = '#ff0000';
        } else if (totalTimeMultiplier > 1) {
          timeColor = '#00ff88';
        } else if (totalTimeMultiplier < 1) {
          timeColor = '#ff6b35';
        }
        
        const timeText = totalTimeMultiplier === 0 ? 'STOPPED' : `${totalTimeMultiplier.toFixed(1)}x`;
        timeDisplay.innerHTML = `<span style="color: ${timeColor};">${timeText}</span>`;
      }
    }
    
    function updateTimeDisplay() {
      const hh = String(player.time.hour).padStart(2, '0');
      
      // Calculate time multiplier from active drugs
      let timeMultiplier = 1.0;
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.timeMultiplier !== undefined && drug.timeMultiplier !== 0) {
          timeMultiplier *= drug.timeMultiplier;
        }
      });
      
      // Handle time stop (Whip Its effect)
      if (player.drugEffects.timeStopDuration > 0) {
        timeMultiplier = 0; // Time is stopped
      }
      
      // In camp mode, use actual game time minutes (no animation)
      // In playa mode, use animated minutes for smooth display
      let mm;
      if (currentWorld === 'camp') {
        // Use actual game time minutes - no animation
        mm = String(player.time.minute).padStart(2, '0');
      } else {
      // Calculate animated minutes based on how far through the hour we are
      const now = Date.now();
      const secondsSinceLastHour = (now - lastTimeUpdate) / 1000;
      
      // Apply time multiplier to the animation speed
      const effectiveSecondsPerMinute = 1 / Math.max(timeMultiplier, 0.1); // Prevent division by zero
      const animatedMinutes = Math.floor((secondsSinceLastHour / effectiveSecondsPerMinute) * 60);
        mm = String(Math.min(animatedMinutes, 59)).padStart(2, '0');
      }
      
      // Calculate day of the week (Burning Man starts on Saturday, Day 1)
      const daysOfWeek = ['Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
      const dayOfWeek = daysOfWeek[(player.time.day - 1) % 7];
      
      // Determine time of day
      let timeOfDay = '';
      if (player.time.hour >= 6 && player.time.hour < 12) {
        timeOfDay = '🌅 Morning';
      } else if (player.time.hour >= 12 && player.time.hour < 18) {
        timeOfDay = '☀️ Day';
      } else if (player.time.hour >= 18 && player.time.hour < 22) {
        timeOfDay = '🌆 Evening';
      } else {
        timeOfDay = '🌙 Night';
      }
      
      // Burning Man timeline info
      let timelineInfo = '';
      if (player.time.day <= BURNING_MAN_DURATION) {
        const daysToMan = MAN_BURN_DAY - player.time.day;
        const daysToTemple = TEMPLE_BURN_DAY - player.time.day;
        
        if (daysToMan > 0) {
          timelineInfo = ` • ${daysToMan} days to Man Burn`;
        } else if (player.time.day === MAN_BURN_DAY) {
          timelineInfo = ' • 🔥 MAN BURNS TONIGHT!';
        } else if (daysToTemple > 0) {
          timelineInfo = ` • ${daysToTemple} days to Temple Burn`;
        } else if (player.time.day === TEMPLE_BURN_DAY) {
          timelineInfo = ' • 🔥 TEMPLE BURNS TONIGHT!';
        } else {
          timelineInfo = ' • Burning Man Complete';
        }
      }
      
      document.getElementById('time-display').textContent = `Day ${player.time.day} (${dayOfWeek}) • ${hh}:${mm} ${timeOfDay}${timelineInfo}`;
    }
    
    function updateInventoryDisplay() {
      const list = document.getElementById('inventory-list');
      list.innerHTML = '';
      
      // Define food items with their effects
      const foodEffects = {
        'Grilled Cheese': { hunger: 25, mood: 8, emoji: '🧀' },
        'Veggie Burger': { hunger: 35, mood: 10, emoji: '🍔' },
        'Fruit Salad': { hunger: 20, mood: 6, emoji: '🥗' },
        'Energy Bar': { hunger: 15, mood: 4, emoji: '🍫' },
        'Pizza Slice': { hunger: 30, mood: 12, emoji: '🍕' },
        'Smoothie': { hunger: 18, mood: 5, emoji: '🥤' },
        'Popsicle': { hunger: 8, mood: 3, emoji: '🍭' },
        'Burrito': { hunger: 28, mood: 9, emoji: '🌯' },
        'Taco': { hunger: 22, mood: 7, emoji: '🌮' },
        'Ice Cream': { hunger: 12, mood: 6, emoji: '🍦' },
        'Pretzel': { hunger: 18, mood: 4, emoji: '🥨' },
        'Corn Dog': { hunger: 25, mood: 8, emoji: '🌭' },
        'Funnel Cake': { hunger: 20, mood: 10, emoji: '🍰' },
        'Nachos': { hunger: 24, mood: 7, emoji: '🧀' },
        'Cotton Candy': { hunger: 5, mood: 2, emoji: '🍬' }
      };
      
      // Define clothing and trinket items with their effects
      const giftableItems = {
        'Clothing': { mood: 15, energy: 10, emoji: '👕' },
        'Trinket': { mood: 12, energy: 8, emoji: '✨' }
      };
      
      Object.keys(player.inventory).forEach(itemName => {
        const quantity = player.inventory[itemName];
        const div = document.createElement('div');
        div.className = 'inventory-item';
        
        // Add emoji, values, and hotkeys for different item types
        let displayName = itemName;
        let hotkey = '';
        
        // Define hotkeys for each item
        const itemHotkeys = {
          'Water': 'W',
          'Trinket': 'T',
          'Clothing': 'L',
          'Grilled Cheese': 'J',
          'Veggie Burger': 'V',
          'Fruit Salad': 'F',
          'Energy Bar': 'E',
          'Pizza Slice': 'P',
          'Smoothie': 'S',
          'Popsicle': 'O',
          'Burrito': 'U',
          'Taco': 'K',
          'Ice Cream': 'I',
          'Pretzel': 'R',
          'Corn Dog': 'N',
          'Funnel Cake': 'M',
          'Nachos': 'Q',
          'Cotton Candy': 'Y',
          'Gas Can': 'G'
        };
        
        if (foodEffects[itemName]) {
          const effect = foodEffects[itemName];
          hotkey = itemHotkeys[itemName] || '';
          displayName = `${effect.emoji} ${itemName} (+${effect.hunger} hunger)`;
        } else if (giftableItems[itemName]) {
          const effect = giftableItems[itemName];
          hotkey = itemHotkeys[itemName] || '';
          displayName = `${effect.emoji} ${itemName} (+${effect.mood} mood, +${effect.energy} energy)`;
        } else if (itemName === 'Water') {
          hotkey = itemHotkeys[itemName] || '';
          displayName = `💧 ${itemName} (+35 thirst)`;
        } else if (itemName === 'Gas Can') {
          hotkey = itemHotkeys[itemName] || '';
          displayName = `⛽ ${itemName} (Deliver to art cars for karma)`;
        }
        
        // Add hotkey to display name
        if (hotkey) {
          displayName = `[${hotkey}] ${displayName}`;
        }
        
        div.innerHTML = `
          <span>${displayName}</span>
          <span class="quantity">${quantity}</span>
        `;
        
        // Add click functionality - items now auto-use themselves
        div.addEventListener('click', () => {
          if (itemName === 'Water') {
            if (!useItem('Water', function(s) { s.thirst += 35; s.mood += 3; })) {
              alert('No water left.');
            }
          } else if (foodEffects[itemName]) {
            const effect = foodEffects[itemName];
            if (!useItem(itemName, function(s) { 
              s.hunger += effect.hunger; 
              s.mood += effect.mood; 
            })) {
              alert(`No ${itemName.toLowerCase()} left.`);
            }
          } else if (giftableItems[itemName]) {
            const effect = giftableItems[itemName];
            // Auto-use the item for personal benefit
            if (!useItem(itemName, function(s) { 
              s.mood += effect.mood; 
              s.energy += effect.energy; 
            })) {
              alert(`No ${itemName.toLowerCase()} left.`);
            }
          }
        });
        
        list.appendChild(div);
      });
    }
    
    function updateDrugEffectsDisplay() {
      const panel = document.getElementById('drug-effects-panel');
      const list = document.getElementById('drug-effects-list');
      const countdownOverlay = document.getElementById('drug-countdown-overlay');
      const countdownText = document.getElementById('countdown-text');
      
      // Clear existing effects
      list.innerHTML = '';
      
      // Show panel only if there are active effects
      if (player.drugEffects.activeDrugs.length > 0) {
        panel.style.display = 'block';
        
        // Show stacked countdown overlay for all active drugs
        const drugCountdowns = player.drugEffects.activeDrugs.map(drug => {
          const displayName = drug.name.includes('Mystery') ? 
            (drug.mysteryType || drug.name) : drug.name;
          return `💊 ${displayName}: ${drug.duration}h`;
        }).join(' | ');
        
        countdownText.textContent = drugCountdowns;
        countdownOverlay.style.display = 'block';
        
        // Add each active drug
        player.drugEffects.activeDrugs.forEach(drug => {
          
          // Add speed effect if active
          if (drug.speedMultiplier !== 1) {
            const speedDiv = document.createElement('div');
            speedDiv.className = 'drug-effect-item';
            
            // Use the drug's actual emoji instead of generic icons
            const speedIcon = drug.emoji || (drug.speedMultiplier > 1 ? '⚡' : '🐌');
            // Show the actual drug type (revealed when consumed) or mystery name
            const displayName = drug.name.includes('Mystery') ? 
              (drug.mysteryType || drug.name) : drug.name;
            const speedText = drug.speedMultiplier > 1 ? 
              `${displayName} Speed (${drug.speedMultiplier}x)` : 
              `${displayName} Slow (${drug.speedMultiplier}x)`;
            const speedColor = drug.speedMultiplier > 1 ? '#00ff88' : '#ff6b35';
            
            speedDiv.innerHTML = `
              <div class="drug-effect-text" style="color: ${speedColor};">${speedText}</div>
              <div class="drug-effect-duration">${drug.duration}h</div>
            `;
            list.appendChild(speedDiv);
          }
          
          // Add hallucination effect if active
          if (drug.hallucinating) {
            const hallDiv = document.createElement('div');
            hallDiv.className = 'drug-effect-item';
            
            // Show the actual drug type (revealed when consumed) or mystery name
            const displayName = drug.name.includes('Mystery') ? 
              (drug.mysteryType || drug.name) : drug.name;
            hallDiv.innerHTML = `
              <div class="drug-effect-text" style="color: #ff6b9d;">${displayName} Hallucinations</div>
              <div class="drug-effect-duration">${drug.duration}h</div>
            `;
            list.appendChild(hallDiv);
          }
          
          // Add time effect if active
          if (drug.timeMultiplier !== undefined && drug.timeMultiplier !== 1) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'drug-effect-item';
            
            const displayName = drug.name.includes('Mystery') ? 
              (drug.mysteryType || drug.name) : drug.name;
            const timeText = drug.timeMultiplier > 1 ? 
              `${displayName} Time Speed (${drug.timeMultiplier}x)` : 
              `${displayName} Time Slow (${drug.timeMultiplier}x)`;
            const timeColor = drug.timeMultiplier > 1 ? '#00ff88' : '#ff6b35';
            
            timeDiv.innerHTML = `
              <div class="drug-effect-text" style="color: ${timeColor};">${timeText}</div>
              <div class="drug-effect-duration">${drug.duration}h</div>
            `;
            list.appendChild(timeDiv);
          }
        });
        
        // Show time stop effect if active
        if (player.drugEffects.timeStopDuration > 0) {
          const timeStopDiv = document.createElement('div');
          timeStopDiv.className = 'drug-effect-item';
          timeStopDiv.innerHTML = `
            <div class="drug-effect-text" style="color: #ff6b35; font-weight: bold;">Time Stopped</div>
            <div class="drug-effect-duration">${player.drugEffects.timeStopDuration}s</div>
          `;
          list.appendChild(timeStopDiv);
        }
      } else {
        panel.style.display = 'none';
        countdownOverlay.style.display = 'none';
      }
    }
    
    // Queue for collection feedback to prevent overlap
    let feedbackQueue = [];
    let feedbackContainer = null;
    
    // Track recent pickups to combine notifications
    let recentPickups = {};
    const PICKUP_COMBINE_TIME = 1000; // Combine pickups within 1 second
    
    function updateLiveActivities() {
      const activitiesContent = document.getElementById('activities-display');
      if (!activitiesContent) return;
      
      const currentDay = player.time.day;
      let announcement = '';
      
      if (currentDay === 1) {
        announcement = 'Welcome to Burning Man! The playa is starting to fill up...';
      } else if (currentDay === 2) {
        announcement = 'More people are arriving! The energy is building...';
      } else if (currentDay === 3) {
        announcement = 'The playa is getting busier! Art cars and bikes everywhere...';
      } else if (currentDay === 4) {
        announcement = 'Midweek vibes! The community is growing stronger...';
      } else if (currentDay === 5) {
        announcement = 'The playa is alive! More art, more music, more magic...';
      } else if (currentDay === 6) {
        announcement = 'The energy is electric! Tomorrow the Man burns!';
      } else if (currentDay === 7) {
        announcement = '🔥 TODAY THE MAN BURNS! 🔥 The playa is at its peak!';
      } else if (currentDay === 8) {
        announcement = '🔥 TODAY THE TEMPLE BURNS! 🔥 The final ceremony... People are leaving...';
      } else if (currentDay === 9) {
        announcement = 'Post-Burning Man... The exodus begins...';
      } else if (currentDay === 10) {
        announcement = 'The playa is emptying fast... Most camps are gone...';
      } else if (currentDay === 11) {
        announcement = 'The playa is empty... Everything has been packed away...';
      } else if (currentDay > 11) {
        announcement = 'Post-Burning Man - The playa returns to dust... Nothing left but memories...';
      }
      
      activitiesContent.innerHTML = `<p>${announcement}</p>`;
    }
    
    function showDayAnnouncement(day) {
      let announcement = '';
      
      if (day === 1) {
        announcement = '🌅 Day 1 - Welcome to Burning Man! The playa is starting to fill up...';
      } else if (day === 2) {
        announcement = '🌅 Day 2 - More people are arriving! The energy is building...';
      } else if (day === 3) {
        announcement = '🌅 Day 3 - The playa is getting busier! Art cars and bikes everywhere...';
      } else if (day === 4) {
        announcement = '🌅 Day 4 - Midweek vibes! The community is growing stronger...';
      } else if (day === 5) {
        announcement = '🌅 Day 5 - The playa is alive! More art, more music, more magic...';
      } else if (day === 6) {
        announcement = '🌅 Day 6 - The energy is electric! Tomorrow the Man burns!';
      } else if (day === 7) {
        announcement = '🔥 Day 7 - TODAY THE MAN BURNS! 🔥 The playa is at its peak!';
      } else if (day === 8) {
        announcement = '🔥 Day 8 - TODAY THE TEMPLE BURNS! 🔥 The final ceremony... People are leaving...';
      } else if (day === 9) {
        announcement = '🌅 Day 9 - Post-Burning Man... The playa is emptying out...';
      } else if (day === 10) {
        announcement = '🌅 Day 10 - Almost everyone is gone... The playa returns to dust...';
      } else if (day === 11) {
        announcement = '🌅 Day 11 - The playa is empty... Everything has been packed away...';
      } else if (day > 11) {
        announcement = '🌅 Post-Burning Man - The playa returns to dust... Nothing left but memories...';
      }
      
      if (announcement) {
        // Update the activities display with the announcement
        updateLiveActivities();
      }
    }
    
    function showCollectionFeedback(text, type, value) {
      // Create container if it doesn't exist
      if (!feedbackContainer) {
        feedbackContainer = document.createElement('div');
        feedbackContainer.id = 'feedback-container';
        feedbackContainer.style.cssText = `
          position: fixed;
          top: 30%;
          left: 50%;
          transform: translate(-50%, 0);
          z-index: 2000;
          pointer-events: none;
        `;
        document.body.appendChild(feedbackContainer);
      }
      
      const feedback = document.createElement('div');
      feedback.className = `collection-feedback ${type}`;
      
      if (type === 'karma') {
        feedback.textContent = `${text} (+${value} Karma)`;
      } else if (type === 'coin') {
        feedback.textContent = text;
      } else if (type === 'water') {
        feedback.textContent = `${text} (+Thirst)`;
      } else if (type === 'food') {
        feedback.textContent = `${text} (+${value} Hunger)`;
      } else if (type === 'drug') {
        // Get the drug's time multiplier for display
        let timeInfo = '';
        const drug = drugs.find(d => d.name === text || d.type === text);
        if (drug && drug.timeMultiplier !== undefined && drug.timeMultiplier !== 1) {
          if (drug.timeMultiplier === 0) {
            timeInfo = ', Time STOPPED';
          } else if (drug.timeMultiplier > 1) {
            timeInfo = `, Time ${drug.timeMultiplier}x`;
          } else {
            timeInfo = `, Time ${drug.timeMultiplier}x`;
          }
        }
        feedback.textContent = `${text} (${value > 1 ? '+' : ''}${value}x Speed${timeInfo})`;
      } else if (type === 'inventory') {
        feedback.textContent = text; // Just show the item name, no additional info
      }
      
      // Add to queue and position
      feedbackQueue.push(feedback);
      updateFeedbackPositions();
      
      feedbackContainer.appendChild(feedback);
      
      // Remove after animation
      setTimeout(() => {
        if (feedback.parentNode) {
          feedback.parentNode.removeChild(feedback);
          const index = feedbackQueue.indexOf(feedback);
          if (index > -1) {
            feedbackQueue.splice(index, 1);
          }
          updateFeedbackPositions();
        }
      }, 3000);
    }
    
    function showDetailedEffects(text, effects, actionType) {
      const modal = document.createElement('div');
      modal.className = 'encounter-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #ffd23f;
        border-radius: 10px;
        padding: 20px;
        color: white;
        font-family: 'Courier New', monospace;
        z-index: 2000;
        max-width: 400px;
        text-align: center;
      `;
      
      let effectsText = '';
      if (effects.energy !== 0) {
        effectsText += `Energy: ${effects.energy > 0 ? '+' : ''}${effects.energy}<br>`;
      }
      if (effects.mood !== 0) {
        effectsText += `Mood: ${effects.mood > 0 ? '+' : ''}${effects.mood}<br>`;
      }
      if (effects.karma !== 0) {
        effectsText += `Karma: ${effects.karma > 0 ? '+' : ''}${effects.karma}<br>`;
      }
      if (effects.thirst !== 0) {
        effectsText += `Thirst: ${effects.thirst > 0 ? '+' : ''}${effects.thirst}<br>`;
      }
      if (effects.hunger !== 0) {
        effectsText += `Hunger: ${effects.hunger > 0 ? '+' : ''}${effects.hunger}<br>`;
      }
      
      modal.innerHTML = `
        <div style="font-size: 1.2em; margin-bottom: 15px; color: #ffd23f;">${text}</div>
        <div style="margin-bottom: 15px;">${effectsText}</div>
      `;
      
      document.body.appendChild(modal);
      
      // Auto-close after 3 seconds
      setTimeout(() => {
        if (modal.parentNode) {
          document.body.removeChild(modal);
        }
      }, 3000);
    }
    
    // New function to handle combined pickup notifications
    function showCombinedPickup(itemType, quantity = 1) {
      const now = Date.now();
      const key = `${itemType}`;
      
      // Check if we have a recent pickup of the same type
      if (recentPickups[key] && (now - recentPickups[key].time) < PICKUP_COMBINE_TIME) {
        // Combine with existing pickup
        recentPickups[key].quantity += quantity;
        recentPickups[key].time = now;
        
        // Update the existing feedback element
        const existingFeedback = recentPickups[key].element;
        if (existingFeedback && existingFeedback.parentNode) {
          let displayText = '';
          if (itemType === 'coin') {
            displayText = `+${recentPickups[key].quantity} Coins`;
          } else if (itemType === 'water') {
            displayText = `+${recentPickups[key].quantity} Water`;
          } else if (itemType === 'moop') {
            displayText = `+${recentPickups[key].quantity} MOOP`;
          } else {
            displayText = `+${recentPickups[key].quantity} ${itemType}`;
          }
          existingFeedback.textContent = displayText;
        }
      } else {
        // Create new pickup notification
        let displayText = '';
        if (itemType === 'coin') {
          displayText = `+${quantity} Coin${quantity > 1 ? 's' : ''}`;
        } else if (itemType === 'water') {
          displayText = `+${quantity} Water`;
        } else if (itemType === 'moop') {
          displayText = `+${quantity} MOOP`;
        } else {
          displayText = `+${quantity} ${itemType}`;
        }
        
        const feedback = document.createElement('div');
        feedback.className = `collection-feedback ${itemType}`;
        feedback.textContent = displayText;
        
        // Store in recent pickups
        recentPickups[key] = {
          element: feedback,
          quantity: quantity,
          time: now
        };
        
        // Create container if it doesn't exist
        if (!feedbackContainer) {
          feedbackContainer = document.createElement('div');
          feedbackContainer.id = 'feedback-container';
          feedbackContainer.style.cssText = `
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 2000;
            pointer-events: none;
          `;
          document.body.appendChild(feedbackContainer);
        }
        
        // Add to queue and position
        feedbackQueue.push(feedback);
        updateFeedbackPositions();
        feedbackContainer.appendChild(feedback);
        
        // Remove after animation
        setTimeout(() => {
          if (feedback.parentNode) {
            feedback.parentNode.removeChild(feedback);
            const index = feedbackQueue.indexOf(feedback);
            if (index > -1) {
              feedbackQueue.splice(index, 1);
            }
            updateFeedbackPositions();
          }
          // Clean up recent pickups
          delete recentPickups[key];
        }, 3000);
      }
    }
    
    function updateFeedbackPositions() {
      feedbackQueue.forEach((feedback, index) => {
        const offset = index * 35; // 35px spacing between items
        feedback.style.transform = `translate(-50%, ${offset}px)`;
      });
    }
    
    
    // Encounter system
    function showEncounter(encounter) {
      const modal = document.createElement('div');
      modal.className = 'encounter-modal';
      modal.innerHTML = `
        <div class="encounter-text">${encounter.text}</div>
        <div class="encounter-choices" id="encounter-choices"></div>
      `;
      document.body.appendChild(modal);
      
      const choicesDiv = document.getElementById('encounter-choices');
      encounter.choices.forEach(choice => {
        const btn = document.createElement('button');
        btn.className = 'choice-btn';
        btn.textContent = choice.label;
        btn.onclick = () => {
          applyEff(choice.eff);
          if (encounter.onExit) encounter.onExit();
          advance(30);
          document.body.removeChild(modal);
          updateStatsDisplay();
        };
        choicesDiv.appendChild(btn);
      });
      
      if (encounter.onEnter) encounter.onEnter();
    }
    
    function doEncounter() {
      const pool = Math.random() < 0.25 ? [encounters[3]] : [encounters[0], encounters[1], encounters[2], encounters[4]];
      const encounter = pick(pool);
      showEncounter(encounter);
    }
    
    // Action functions
    const actions = {
      explore: () => doEncounter(),
      
      chore: () => {
        const chores = [
          { name: 'Ice Run', coin: 3, karma: 30, energy: -8, thirst: 5, text: 'You go on an ice run to keep the camp cool.' },
          { name: 'Grease Trap', coin: 6, karma: 30, energy: -12, mood: -2, text: 'You clean out the grease trap - dirty work but necessary.' },
          { name: 'MOOP Sweep', coin: 2, karma: 30, energy: -5, text: 'You sweep for MOOP (Matter Out Of Place) to keep the playa clean.' }
        ];
        const job = pick(chores);
        
        // Apply stat changes
        player.stats.coin += job.coin;
        player.stats.karma += job.karma;
        player.stats.energy += job.energy;
        if (job.thirst) player.stats.thirst += job.thirst;
        if (job.mood) player.stats.mood += job.mood;
        
        // Clamp stats
        player.stats.coin = clamp(player.stats.coin, 0, 9999);
        player.stats.karma = clamp(player.stats.karma, 0, 9999);
        player.stats.energy = clamp(player.stats.energy, 0, 100);
        player.stats.thirst = clamp(player.stats.thirst, 0, 100);
        player.stats.mood = clamp(player.stats.mood, 0, 100);
        
        // Set 60-second cooldown
        player.lastActionTimes.chore = Date.now();
        
        // Show feedback
        let feedbackText = `${job.text} `;
        if (job.coin > 0) feedbackText += `+${job.coin} Coins `;
        if (job.karma > 0) feedbackText += `+${job.karma} Karma `;
        if (job.energy > 0) feedbackText += `+${job.energy} Energy `;
        if (job.energy < 0) feedbackText += `${job.energy} Energy `;
        if (job.thirst) feedbackText += `+${job.thirst} Thirst `;
        if (job.mood) feedbackText += `${job.mood} Mood `;
        
        showCollectionFeedback(feedbackText.trim(), 'karma', 0);
        
        advance(30);
        updateStatsDisplay();
      },
      
      rest: () => {
        // Start napping
        player.sleeping = true;
        player.sleepStartTime = Date.now();
        showCollectionFeedback('Taking a nap... Press any key to wake up early!', 'energy', 0);
        advance(5); // Small time advance for starting the nap
      },
      
      shop: () => {
        const modal = document.createElement('div');
        modal.className = 'encounter-modal';
        modal.innerHTML = `
          <div class="modal-close" onclick="closeModal('shop')">×</div>
          <div class="encounter-text">Welcome to Center Camp! What would you like to buy?</div>
          <div class="encounter-choices" id="shop-choices"></div>
        `;
        document.body.appendChild(modal);
        
        const choicesDiv = document.getElementById('shop-choices');
        
        // Ice option
        const iceBtn = document.createElement('button');
        iceBtn.className = 'choice-btn';
        iceBtn.textContent = `🧊 Ice (15 coins) - Increases karma`;
        iceBtn.onclick = () => {
          if (player.stats.coin >= 15) {
            document.body.removeChild(modal);
            applyEff(function(s) { 
              s.coin -= 15; 
              s.karma += 25; 
            });
            advance(10);
            updateStatsDisplay();
            showCollectionFeedback('Bought ice! +25 Karma', 'karma', 25);
          } else {
            alert('Not enough coins! You need 15 coins for ice.');
          }
        };
        choicesDiv.appendChild(iceBtn);
        
        // Tea option
        const teaBtn = document.createElement('button');
        teaBtn.className = 'choice-btn';
        teaBtn.textContent = `🍵 Tea (5 coins) - Increases energy and mood`;
        teaBtn.onclick = () => {
          if (player.stats.coin >= 5) {
            document.body.removeChild(modal);
            applyEff(function(s) { 
              s.coin -= 5; 
              s.energy += 15; 
              s.mood += 10; 
            });
            advance(10);
            updateStatsDisplay();
            showCollectionFeedback('Bought tea! +15 Energy, +10 Mood', 'mood', 10);
          } else {
            alert('Not enough coins! You need 5 coins for tea.');
          }
        };
        choicesDiv.appendChild(teaBtn);
        
        // Cancel option
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'choice-btn';
        cancelBtn.textContent = 'Never mind';
        cancelBtn.onclick = () => {
          document.body.removeChild(modal);
        };
        choicesDiv.appendChild(cancelBtn);
      },
      
      help: () => {
        const helpOptions = [
          { name: 'Help with Setup', karma: 4, mood: 8, energy: -12, text: 'You help a fellow burner set up their camp.' },
          { name: 'Give Directions', karma: 2, mood: 4, energy: -4, text: 'You help someone find their way around the playa.' },
          { name: 'Share Supplies', karma: 3, mood: 6, energy: -6, text: 'You share some of your supplies with someone in need.' },
          { name: 'Teach Something', karma: 5, mood: 8, energy: -8, text: 'You teach someone a new skill or share knowledge.' },
          { name: 'Listen & Support', karma: 2, mood: -10, energy: -8, text: 'You provide emotional support to someone going through a tough time.' }
        ];
        
        const modal = document.createElement('div');
        modal.className = 'encounter-modal';
        modal.innerHTML = `
          <div class="modal-close" onclick="closeModal('help')">×</div>
          <div class="encounter-text">You encounter someone who needs help. What do you do?</div>
          <div class="encounter-choices" id="help-choices"></div>
        `;
        document.body.appendChild(modal);
        
        const choicesDiv = document.getElementById('help-choices');
        helpOptions.forEach(option => {
          const btn = document.createElement('button');
          btn.className = 'choice-btn';
          
          // Check if player has enough energy and mood for this option
          const hasEnoughEnergy = player.stats.energy >= Math.abs(option.energy);
          const hasEnoughMood = option.mood >= 0 || player.stats.mood >= Math.abs(option.mood);
          const canAfford = hasEnoughEnergy && hasEnoughMood;
          
          // Grey out if can't afford
          if (!canAfford) {
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
            btn.disabled = true;
          }
          
          btn.textContent = `${option.name} (${option.karma} karma, ${option.mood} mood, ${option.energy} energy)`;
          
          // Add visual indicators for insufficient stats
          let statusText = '';
          if (!hasEnoughEnergy) statusText += ' [Need Energy]';
          if (!hasEnoughMood) statusText += ' [Need Mood]';
          if (statusText) {
            btn.textContent += statusText;
          }
          
          btn.onclick = () => {
            // Double-check affordability before proceeding
            if (!canAfford) {
              showCollectionFeedback('Not enough energy or mood for this action!', 'mood', 0);
              return;
            }
            
            document.body.removeChild(modal);
            applyEff(function(s) { 
              s.karma += option.karma; 
              s.mood += option.mood; 
              s.energy += option.energy; 
            });
            advance(20);
            updateStatsDisplay();
          };
          choicesDiv.appendChild(btn);
        });
      },
      
      battle: () => {
        const moves = ['Glitter Bomb', 'Bass Drop', 'Cuddle Beam'];
        const beats = { 'Glitter Bomb': 'Cuddle Beam', 'Cuddle Beam': 'Bass Drop', 'Bass Drop': 'Glitter Bomb' };
        const askFirst = rnd(0.7);
        
        const modal = document.createElement('div');
        modal.className = 'encounter-modal';
        modal.innerHTML = `
          <div class="modal-close" onclick="closeModal('battle')">×</div>
          <div class="encounter-text">Silly duel! Pick a move (ask for consent first for +karma).</div>
          <div class="encounter-choices" id="battle-choices"></div>
        `;
        document.body.appendChild(modal);
        
        const choicesDiv = document.getElementById('battle-choices');
        moves.forEach(move => {
          const btn = document.createElement('button');
          btn.className = 'choice-btn';
          btn.textContent = move;
          btn.onclick = () => {
            const foe = pick(moves);
            let text = `You chose ${move}. Foe chose ${foe}. `;
            let statChanges = [];
            
            if (askFirst) { 
              applyEff(function(s) { s.karma += 2; }); 
              text += '(You asked first — nice!) ';
              statChanges.push('+2 Karma');
            }
            
            if (beats[move] === foe) { 
              applyEff(function(s) { s.coin += 3; s.mood += 3; }); 
              text += 'You win!';
              statChanges.push('+3 Coins', '+3 Mood');
            } else if (beats[foe] === move) { 
              applyEff(function(s) { s.mood -= 2; }); 
              text += 'You lose, but it was silly.';
              statChanges.push('-2 Mood');
            } else { 
              text += 'A tie. Everyone sparkles.';
            }
            
            // Show stat changes in the text
            if (statChanges.length > 0) {
              text += ` (${statChanges.join(', ')})`;
            }
            
            modal.innerHTML = `
              <div class="encounter-text">${text}</div>
              <button class="choice-btn" onclick="document.body.removeChild(this.parentElement); advance(15); updateStatsDisplay();">Continue</button>
            `;
            updateStatsDisplay();
          };
          choicesDiv.appendChild(btn);
        });
      },
      
      board: () => {
        
        if (nearbyArtCar && ridingArtCar === null && ridingBike === null) {
          ridingArtCar = nearbyArtCar;
          nearbyArtCar.hasPassenger = true;
          // Position player in center of car platform
          player.worldX = nearbyArtCar.x + nearbyArtCar.w / 2 - player.w / 2;
          player.worldY = nearbyArtCar.y + nearbyArtCar.h / 2 - player.h / 2;
          updateTransportButtons();
        } else if (nearbyBike && ridingBike === null && ridingArtCar === null) {
          ridingBike = nearbyBike;
          updateTransportButtons();
        } else {
        }
      },
      
      dismount: () => {
        
        // Force dismount regardless of button state
        if (ridingArtCar || ridingBike) {
          if (ridingArtCar) {
            ridingArtCar.hasPassenger = false;
            lastExitTime = Date.now();
            
            // Position player well outside the art car to avoid collision bugs
            const carCenterX = ridingArtCar.x + ridingArtCar.w / 2;
            const carCenterY = ridingArtCar.y + ridingArtCar.h / 2;
            const playerCenterX = player.worldX + player.w / 2;
            const playerCenterY = player.worldY + player.h / 2;
            
            // Calculate direction away from car center
            const dx = playerCenterX - carCenterX;
            const dy = playerCenterY - carCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Much larger push distance to avoid collision issues
            const pushDistance = Math.max(ridingArtCar.w, ridingArtCar.h) / 2 + 80;
            
            if (distance > 0) {
              // Normalize and push player much further away
              const normalizedX = dx / distance;
              const normalizedY = dy / distance;
              
              player.worldX = carCenterX + normalizedX * pushDistance - player.w / 2;
              player.worldY = carCenterY + normalizedY * pushDistance - player.h / 2;
            } else {
              // If player is exactly at center, push them to the right
              player.worldX = carCenterX + pushDistance - player.w / 2;
              player.worldY = carCenterY - player.h / 2;
            }
            
            // Check if player is colliding with any other art car and adjust position if needed
            let colliding = false;
            do {
              colliding = false;
              for (let otherCar of artCars) {
                if (otherCar !== ridingArtCar) {
                  if (player.worldX < otherCar.x + otherCar.w && 
                      player.worldX + player.w > otherCar.x &&
                      player.worldY < otherCar.y + otherCar.h && 
                      player.worldY + player.h > otherCar.y) {
                    colliding = true;
                    // Push player further away from this collision
                    const otherCenterX = otherCar.x + otherCar.w / 2;
                    const otherCenterY = otherCar.y + otherCar.h / 2;
                    const dx2 = player.worldX + player.w/2 - otherCenterX;
                    const dy2 = player.worldY + player.h/2 - otherCenterY;
                    const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    
                    if (dist2 > 0) {
                      const normX = dx2 / dist2;
                      const normY = dy2 / dist2;
                      const escapeDistance = Math.max(otherCar.w, otherCar.h) / 2 + 60;
                      
                      player.worldX = otherCenterX + normX * escapeDistance - player.w / 2;
                      player.worldY = otherCenterY + normY * escapeDistance - player.h / 2;
                    }
                    break;
                  }
                }
              }
            } while (colliding);
            
            
            // Reset player offset when dismounting
            if (ridingArtCar.playerOffset) {
              ridingArtCar.playerOffset = null;
            }
            
            // Clear the reference immediately
            ridingArtCar = null;
          }
          if (ridingBike) {
            ridingBike = null;
          }
          
          // Force button update and ensure movement works
          setTimeout(() => {
            updateTransportButtons();
          }, 100);
        } else {
          // Emergency dismount - clear everything
          ridingArtCar = null;
          ridingBike = null;
          updateTransportButtons();
        }
      },
      
      // Helper function to refresh gift grid
      refreshGiftGrid: () => {
        const gridDiv = document.getElementById('gift-grid');
        if (!gridDiv) return;
        
        // Clear existing items
        gridDiv.innerHTML = '';
        
        // Define gift items with emojis and rewards
        const giftItems = [
          { name: 'Water', emoji: '💧', karma: 5, mood: 4, text: 'You share your water with someone in need.' },
          { name: 'Clothing', emoji: '👕', karma: 6, mood: 7, text: 'You gift some clothing to someone who needs it.' },
          { name: 'Trinket', emoji: '✨', karma: 4, mood: 6, text: 'You gift a small trinket to a fellow burner.' },
          { name: 'Grilled Cheese', emoji: '🧀', karma: 4, mood: 5, text: 'You offer grilled cheese to a hungry stranger.' },
          { name: 'Veggie Burger', emoji: '🥬', karma: 4, mood: 5, text: 'You offer veggie burger to a hungry stranger.' },
          { name: 'Fruit Salad', emoji: '🥗', karma: 4, mood: 5, text: 'You offer fruit salad to a hungry stranger.' },
          { name: 'Energy Bar', emoji: '🍫', karma: 4, mood: 5, text: 'You offer energy bar to a hungry stranger.' },
          { name: 'Pizza Slice', emoji: '🍕', karma: 4, mood: 5, text: 'You offer pizza slice to a hungry stranger.' },
          { name: 'Smoothie', emoji: '🥤', karma: 4, mood: 5, text: 'You offer smoothie to a hungry stranger.' },
          { name: 'Popsicle', emoji: '🍭', karma: 4, mood: 5, text: 'You offer popsicle to a hungry stranger.' },
          { name: 'Burrito', emoji: '🌯', karma: 4, mood: 5, text: 'You offer burrito to a hungry stranger.' },
          { name: 'Taco', emoji: '🌮', karma: 4, mood: 5, text: 'You offer taco to a hungry stranger.' },
          { name: 'Ice Cream', emoji: '🍦', karma: 4, mood: 5, text: 'You offer ice cream to a hungry stranger.' },
          { name: 'Corn Dog', emoji: '🌭', karma: 4, mood: 5, text: 'You offer corn dog to a hungry stranger.' },
          { name: 'Funnel Cake', emoji: '🍰', karma: 4, mood: 5, text: 'You offer funnel cake to a hungry stranger.' },
          { name: 'Nachos', emoji: '🧀', karma: 4, mood: 5, text: 'You offer nachos to a hungry stranger.' },
          { name: 'Cotton Candy', emoji: '🍬', karma: 4, mood: 5, text: 'You offer cotton candy to a hungry stranger.' }
        ];
        
        // Add inventory items
        giftItems.forEach(item => {
          const quantity = player.inventory[item.name] || 0;
          if (quantity > 0) {
            const giftDiv = document.createElement('div');
            giftDiv.className = 'gift-item';
            giftDiv.innerHTML = `
              <div class="gift-emoji">${item.emoji}</div>
              <div class="gift-quantity">${quantity}</div>
              <div class="gift-rewards">+${item.karma} +${item.mood}</div>
            `;
            
            giftDiv.onclick = () => {
              // Simple gift logic - just give one item at a time
              const success = useItem(item.name, () => {});
              if (success) {
                applyEff(function(s) { 
                  s.karma += item.karma; 
                  s.mood += item.mood; 
                });
                
                showCollectionFeedback(item.text, 'karma', item.karma);
                advance(15);
                updateStatsDisplay();
                updateInventoryDisplay();
                
                // Refresh the gift grid to update quantities
                setTimeout(() => {
                  actions.refreshGiftGrid();
                }, 50);
              }
            };
            
            gridDiv.appendChild(giftDiv);
          }
        });
        
        // Add free hug option
        const hugDiv = document.createElement('div');
        hugDiv.className = 'gift-item';
        hugDiv.innerHTML = `
          <div class="gift-emoji">🤗</div>
          <div class="gift-quantity">∞</div>
          <div class="gift-rewards">+2 +8</div>
        `;
        
        hugDiv.onclick = () => {
                    applyEff(function(s) { 
            s.karma += 2; 
            s.mood += 8; 
                    });
          
          showCollectionFeedback('You give someone a warm playa hug.', 'karma', 2);
                    advance(15);
                    updateStatsDisplay();
        };
        
        gridDiv.appendChild(hugDiv);
      },
      
      gift: () => {
        // Check if we have any items to give
        const hasItems = Object.keys(player.inventory).some(itemName => (player.inventory[itemName] || 0) > 0);
        
        if (!hasItems) {
          showCollectionFeedback('You have nothing to give!', 'mood', 0);
          return;
        }
        
        const modal = document.createElement('div');
        modal.className = 'encounter-modal';
        modal.innerHTML = `
          <div class="modal-close" onclick="closeModal('gift')">×</div>
          <div class="encounter-text">You want to give a gift to someone. What do you offer?</div>
          <div class="gift-grid" id="gift-grid"></div>
          <div style="text-align: center; margin-top: 10px;">
            <button class="choice-btn" id="cancel-gift-btn">Cancel</button>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Use the refresh function to populate the grid
        actions.refreshGiftGrid();
        
        // Add cancel button functionality
        const cancelBtn = document.getElementById('cancel-gift-btn');
        cancelBtn.onclick = () => {
          document.body.removeChild(modal);
          advance(5);
        };
      },
      
      dance: () => {
        // Check cooldown
        if (player.cooldowns.dance > 0) {
          showCollectionFeedback(`Dancing on cooldown for ${player.cooldowns.dance} more days`, 'mood', 0);
          return;
        }
        
        const danceStyles = [
          { name: 'Freeform', energy: -8, mood: 12, karma: 1, text: 'You dance freely to the music.' },
          { name: 'Partner Dance', energy: -6, mood: 15, karma: 3, text: 'You dance with a fellow burner.' },
          { name: 'Fire Dance', energy: -12, mood: 20, karma: 5, text: 'You dance near the fire performers.' },
          { name: 'Silent Disco', energy: -4, mood: 8, karma: 2, text: 'You dance at a silent disco.' }
        ];
        
        const dance = pick(danceStyles);
        
        // Apply effects immediately
        applyEff(function(s) { 
          s.energy += dance.energy; 
          s.mood += dance.mood; 
          s.karma += dance.karma; 
        });
        
        // Set cooldown (1 day)
        player.cooldowns.dance = 1;
        
        // Show detailed effects
        showDetailedEffects(dance.text, {
          energy: dance.energy,
          mood: dance.mood,
          karma: dance.karma,
          thirst: 0,
          hunger: 0
        }, 'dance');
        
        advance(20);
        updateStatsDisplay();
      },
      
      climb: () => {
        const climbOptions = [
          { name: 'Small Block', energy: -3, mood: 5, karma: 1, text: 'You climb on a small decorative block.' },
          { name: 'Colorful Block', energy: -4, mood: 7, karma: 2, text: 'You climb a colorful decorative block.' },
          { name: 'Sparkly Block', energy: -2, mood: 6, karma: 1, text: 'You climb a sparkly decorative block.' },
          { name: 'Artistic Block', energy: -5, mood: 8, karma: 3, text: 'You climb an artistic decorative block.' }
        ];
        
        const climb = pick(climbOptions);
        
        // Apply effects immediately
        applyEff(function(s) { 
          s.energy += climb.energy; 
          s.mood += climb.mood; 
          s.karma += climb.karma; 
        });
        
        // Set 20-second cooldown
        player.lastActionTimes.climb = Date.now();
        
        // Show detailed effects
        showDetailedEffects(climb.text, {
          energy: climb.energy,
          mood: climb.mood,
          karma: climb.karma,
          thirst: 0,
          hunger: 0
        }, 'climb');
        
        advance(25);
        updateStatsDisplay();
      },
      
      orgy: () => {
        const orgyOptions = [
          { name: 'Cuddle Puddle', mood: 15, karma: 8, energy: -5, text: 'You join a consenting cuddle puddle.' },
          { name: 'Kink Party', mood: 20, karma: 5, energy: -8, text: 'You participate in a kink-themed gathering.' },
          { name: 'Sacred Sexuality', mood: 25, karma: 12, energy: -10, text: 'You join a sacred sexuality workshop.' },
          { name: 'Polyamory Circle', mood: 18, karma: 10, energy: -6, text: 'You participate in a polyamory discussion circle.' }
        ];
        
        const orgy = pick(orgyOptions);
        
        // Apply effects immediately
        player.stats.mood += orgy.mood;
        player.stats.karma += orgy.karma;
        player.stats.energy += orgy.energy;
        
        // Clamp stats
        player.stats.mood = clamp(player.stats.mood, 0, 100);
        player.stats.karma = clamp(player.stats.karma, 0, 9999);
        player.stats.energy = clamp(player.stats.energy, 0, 100);
        
        // Set cooldown
        player.cooldowns.orgy = 3; // 3 hour cooldown
        
        // Show feedback with stats gained
        let feedbackText = `${orgy.text} `;
        if (orgy.mood > 0) feedbackText += `+${orgy.mood} Mood `;
        if (orgy.karma > 0) feedbackText += `+${orgy.karma} Karma `;
        if (orgy.energy > 0) feedbackText += `+${orgy.energy} Energy `;
        if (orgy.energy < 0) feedbackText += `${orgy.energy} Energy `;
        
        showCollectionFeedback(feedbackText.trim(), 'mood', 0);
        
        advance(45);
        updateStatsDisplay();
      },
      
      meditate: () => {
        const meditationTypes = [
          { name: 'Sunrise Meditation', mood: 15, karma: 5, energy: 5, text: 'You meditate during the beautiful sunrise.' },
          { name: 'Temple Meditation', mood: 20, karma: 8, energy: 8, text: 'You find peace in the temple.' },
          { name: 'Sound Meditation', mood: 12, karma: 3, energy: 3, text: 'You meditate to ambient playa sounds.' },
          { name: 'Group Meditation', mood: 18, karma: 6, energy: 6, text: 'You join a group meditation session.' }
        ];
        
        const meditation = pick(meditationTypes);
        
        const modal = document.createElement('div');
        modal.className = 'encounter-modal';
        modal.innerHTML = `
          <div class="encounter-text">${meditation.text}</div>
          <button class="choice-btn" onclick="document.body.removeChild(this.parentElement); player.tripStats.meditationCount++; applyEff(function(s) { s.mood += ${meditation.mood}; s.karma += ${meditation.karma}; s.energy += ${meditation.energy}; }); advance(30); updateStatsDisplay();">Continue</button>
        `;
        document.body.appendChild(modal);
      },
      
      buyGas: () => {
        const gasPrice = 15; // Cost in coins
        
        if (player.stats.coin < gasPrice) {
          showCollectionFeedback(`Not enough coins! Gas costs ${gasPrice} coins.`, 'mood', 0);
          return;
        }
        
        // Buy gas can
        player.stats.coin -= gasPrice;
        if (player.inventory['Gas Can']) {
          player.inventory['Gas Can']++;
        } else {
          player.inventory['Gas Can'] = 1;
        }
        
        showCollectionFeedback(`Bought gas can for ${gasPrice} coins!`, 'mood', 0);
        updateStatsDisplay();
        updateInventoryDisplay();
      }
    };

    function getDayNightBackgroundColor() {
      const hour = player.time.hour;
      
      // Base color (daytime)
      const baseColor = "#D2B48C"; // Medium tan
      
      // Calculate brightness factor (0 = darkest night, 1 = brightest day)
      let brightness = 1;
      
      if (hour >= 18 || hour < 6) { // 6 PM - 6 AM (night)
        if (hour >= 18 && hour < 20) { // 6 PM - 8 PM (sunset)
          brightness = 1 - ((hour - 18) / 2) * 0.6; // Fade to 40% brightness
        } else if (hour >= 20 && hour < 24) { // 8 PM - 12 AM (darker)
          brightness = 0.4 - ((hour - 20) / 4) * 0.25; // Fade to 15% brightness
        } else if (hour >= 0 && hour < 4) { // 12 AM - 4 AM (darkest)
          brightness = 0.15; // Very dark
        } else if (hour >= 4 && hour < 6) { // 4 AM - 6 AM (dawn)
          brightness = 0.15 + ((hour - 4) / 2) * 0.85; // Fade back to full brightness
        }
      } else { // 6 AM - 6 PM (day)
        brightness = 1; // Full brightness
      }
      
      // Convert hex to RGB, apply brightness, convert back to hex
      const hex = baseColor.replace('#', '');
      const r = Math.floor(parseInt(hex.substr(0, 2), 16) * brightness);
      const g = Math.floor(parseInt(hex.substr(2, 2), 16) * brightness);
      const b = Math.floor(parseInt(hex.substr(4, 2), 16) * brightness);
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    // Draw the Man structure with growing limbs - more like actual Burning Man
    function drawMan() {
      const screenX = manStructure.x - camera.x;
      const screenY = manStructure.y - camera.y;
      
      // Only draw if on screen
      if (screenX > -manStructure.w && screenX < canvas.width && 
          screenY > -manStructure.h && screenY < canvas.height) {
        
        // Calculate body dimensions (used in both burned and unburned states)
        const bodyWidth = 25 + (manStructure.limbs * 2); // Gets wider as it's built
        const bodyHeight = 80 + (manStructure.limbs * 5); // Gets taller as it's built
        
        // Only draw the Man if it hasn't burned yet
        if (!manStructure.burned) {
          // Draw the distinctive Burning Man silhouette
          ctx.fillStyle = '#654321'; // Darker wood color
          
          // Draw main body as a trapezoid
          ctx.beginPath();
          ctx.moveTo(screenX + manStructure.w/2 - bodyWidth/2, screenY + bodyHeight);
          ctx.lineTo(screenX + manStructure.w/2 - bodyWidth/3, screenY + 20);
          ctx.lineTo(screenX + manStructure.w/2 + bodyWidth/3, screenY + 20);
          ctx.lineTo(screenX + manStructure.w/2 + bodyWidth/2, screenY + bodyHeight);
          ctx.closePath();
          ctx.fill();
          
          // Draw outstretched arms (signature Burning Man pose)
          if (manStructure.limbs >= 2) {
            const armLength = 40 + (manStructure.limbs * 3);
            const armY = screenY + 25;
            
            // Left arm (outstretched)
            ctx.beginPath();
            ctx.moveTo(screenX + manStructure.w/2 - bodyWidth/3, armY);
            ctx.lineTo(screenX + manStructure.w/2 - bodyWidth/3 - armLength, armY - 10);
            ctx.lineWidth = 8 + (manStructure.limbs * 2);
            ctx.strokeStyle = '#654321';
            ctx.stroke();
            
            // Right arm (outstretched)
            ctx.beginPath();
            ctx.moveTo(screenX + manStructure.w/2 + bodyWidth/3, armY);
            ctx.lineTo(screenX + manStructure.w/2 + bodyWidth/3 + armLength, armY - 10);
            ctx.stroke();
          }
          
          // Draw legs
          if (manStructure.limbs >= 4) {
            const legWidth = 12;
            const legHeight = 30 + (manStructure.limbs * 2);
            const legY = screenY + bodyHeight;
            
            // Left leg
            ctx.fillRect(screenX + manStructure.w/2 - bodyWidth/2 + 5, legY, legWidth, legHeight);
            
            // Right leg
            ctx.fillRect(screenX + manStructure.w/2 + bodyWidth/2 - 5 - legWidth, legY, legWidth, legHeight);
          }
          
          // Draw the iconic neon circle around the Man (when fully built)
          if (manStructure.limbs >= 6) {
            const circleRadius = 80 + (manStructure.limbs * 5);
            ctx.strokeStyle = '#00FFFF'; // Bright cyan
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(screenX + manStructure.w/2, screenY + bodyHeight/2, circleRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add some sparkle effects
            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              const sparkleX = screenX + manStructure.w/2 + Math.cos(angle) * circleRadius;
              const sparkleY = screenY + bodyHeight/2 + Math.sin(angle) * circleRadius;
              ctx.fillRect(sparkleX - 1, sparkleY - 1, 2, 2);
            }
          }
          
          // Draw construction progress indicator (only if not burned)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`The Man: ${Math.round(manStructure.constructionProgress)}%`, 
                      screenX + manStructure.w/2, screenY - 15);
        }
        
        // If burned, show pile of ashes
        if (manStructure.burned) {
          // Draw pile of ashes where the Man used to be
          const ashWidth = 60;
          const ashHeight = 20;
          const ashX = screenX + manStructure.w/2 - ashWidth/2;
          const ashY = screenY + bodyHeight - ashHeight;
          
          // Main ash pile (dark gray)
          ctx.fillStyle = '#2C2C2C';
          ctx.beginPath();
          ctx.ellipse(ashX + ashWidth/2, ashY + ashHeight/2, ashWidth/2, ashHeight/2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Add some lighter ash particles scattered around
          ctx.fillStyle = '#4A4A4A';
          for (let i = 0; i < 15; i++) {
            const ashParticleX = ashX + (Math.random() - 0.5) * ashWidth * 1.5;
            const ashParticleY = ashY + (Math.random() - 0.5) * ashHeight * 2;
            const particleSize = Math.random() * 3 + 1;
            ctx.fillRect(ashParticleX, ashParticleY, particleSize, particleSize);
          }
          
          // Add some white ash embers
          ctx.fillStyle = '#8B8B8B';
          for (let i = 0; i < 8; i++) {
            const emberX = ashX + (Math.random() - 0.5) * ashWidth;
            const emberY = ashY + (Math.random() - 0.5) * ashHeight;
            ctx.fillRect(emberX, emberY, 2, 2);
          }
          
          // Text indicating the Man has burned
          ctx.fillStyle = '#666666';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('🔥 THE MAN BURNED 🔥', screenX + manStructure.w/2, screenY - 15);
        }
      }
    }
    
    // Draw the Temple structure with progressive construction
    function drawTemple() {
      const screenX = templeStructure.x - camera.x;
      const screenY = templeStructure.y - camera.y;
      
      // Only draw if on screen
      if (screenX > -templeStructure.w && screenX < canvas.width && 
          screenY > -templeStructure.h && screenY < canvas.height) {
        
        // Draw temple based on construction progress
        const constructionHeight = (templeStructure.constructionProgress / 100) * templeStructure.h;
        
        // Base structure (always visible)
        ctx.fillStyle = '#D2691E'; // Chocolate color
        ctx.fillRect(screenX, screenY + templeStructure.h - constructionHeight, 
                    templeStructure.w, constructionHeight);
        
        // Draw roof when construction is advanced enough
        if (templeStructure.constructionProgress > 30) {
          ctx.fillStyle = '#B22222'; // Fire brick color
          ctx.beginPath();
          ctx.moveTo(screenX, screenY + templeStructure.h - constructionHeight);
          ctx.lineTo(screenX + templeStructure.w/2, screenY + templeStructure.h - constructionHeight - 20);
          ctx.lineTo(screenX + templeStructure.w, screenY + templeStructure.h - constructionHeight);
          ctx.closePath();
          ctx.fill();
        }
        
        // Draw columns when construction is advanced enough
        if (templeStructure.constructionProgress > 50) {
          ctx.fillStyle = '#F5F5DC'; // Beige color
          for (let i = 0; i < 4; i++) {
            const columnX = screenX + 15 + (i * 20);
            const columnHeight = Math.min(40, constructionHeight * 0.8);
            ctx.fillRect(columnX, screenY + templeStructure.h - columnHeight, 8, columnHeight);
          }
        }
        
        // Draw construction progress indicator
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Temple: ${Math.round(templeStructure.constructionProgress)}%`, 
                    screenX + templeStructure.w/2, screenY - 10);
        
        // If burned, show fire effect
        if (templeStructure.burned) {
          ctx.fillStyle = '#FF4500';
          ctx.font = '16px Arial';
          ctx.fillText('🔥 BURNED 🔥', screenX + templeStructure.w/2, screenY + templeStructure.h/2);
        }
      }
    }

    // Draw the circle around the Man
    function drawManCircle() {
      const circleCenterX = manStructure.x + manStructure.w/2 - camera.x;
      const circleCenterY = manStructure.y + manStructure.h/2 - camera.y;
      
      // Only draw if on screen
      if (circleCenterX > -MAN_CIRCLE_RADIUS && circleCenterX < canvas.width + MAN_CIRCLE_RADIUS &&
          circleCenterY > -MAN_CIRCLE_RADIUS && circleCenterY < canvas.height + MAN_CIRCLE_RADIUS) {
        
        ctx.strokeStyle = '#FFFF00'; // Bright yellow
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]); // Dashed line
        ctx.beginPath();
        ctx.arc(circleCenterX, circleCenterY, MAN_CIRCLE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
        
        // Add some markers around the circle (like real Burning Man)
        ctx.fillStyle = '#FFFF00';
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const markerX = circleCenterX + Math.cos(angle) * MAN_CIRCLE_RADIUS;
          const markerY = circleCenterY + Math.sin(angle) * MAN_CIRCLE_RADIUS;
          ctx.fillRect(markerX - 2, markerY - 2, 4, 4);
        }
      }
    }

    // Draw the trash fence around the playa
    function drawTrashFence() {
      const playaCenterX = 0 - camera.x;
      const playaCenterY = 0 - camera.y;
      
      // Only draw if on screen
      if (playaCenterX > -PLAYA_RADIUS && playaCenterX < canvas.width + PLAYA_RADIUS &&
          playaCenterY > -PLAYA_RADIUS && playaCenterY < canvas.height + PLAYA_RADIUS) {
        
        // Draw the fence posts
        ctx.fillStyle = '#8B4513'; // Brown fence posts
        for (let i = 0; i < 96; i++) {
          const angle = (i / 96) * Math.PI * 2;
          const postX = playaCenterX + Math.cos(angle) * TRASH_FENCE_RADIUS;
          const postY = playaCenterY + Math.sin(angle) * TRASH_FENCE_RADIUS;
          
          // Only draw if on screen
          if (postX > -10 && postX < canvas.width + 10 && postY > -20 && postY < canvas.height + 20) {
            ctx.fillRect(postX - 2, postY - 20, 4, 20);
          }
        }
        
        // Draw the fence wire
        ctx.strokeStyle = '#C0C0C0'; // Silver wire
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 2]);
        ctx.beginPath();
        ctx.arc(playaCenterX, playaCenterY, TRASH_FENCE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
        
        // Draw "TRASH FENCE" signs
        ctx.fillStyle = '#FF0000';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const signX = playaCenterX + Math.cos(angle) * (TRASH_FENCE_RADIUS - 30);
          const signY = playaCenterY + Math.sin(angle) * (TRASH_FENCE_RADIUS - 30);
          
          if (signX > -50 && signX < canvas.width + 50 && signY > -10 && signY < canvas.height + 10) {
            ctx.fillText('TRASH FENCE', signX, signY);
          }
        }
      }
    }

    function draw() {
      // Clear canvas with dynamic day/night background
      const backgroundColor = getDayNightBackgroundColor();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw decorations
      drawDecorations();
      
      // Draw collectibles
      drawCoins();
      drawWaterBottles();
      drawSnacks();
      
      // Draw art cars
      drawBikes();
      drawArtCars();
      drawNPCs();
      drawGasolineTanks();
      drawMoop();
      drawDrugs();
      drawSpecialLocations();
      
      // Draw Man and Temple structures (only in playa mode)
      if (currentWorld === 'playa') {
      drawMan();
      drawTemple();
      }
      
      // Draw the circle around the Man (only in playa mode)
      if (currentWorld === 'playa') {
      drawManCircle();
      }
      
      // Draw the trash fence (only in playa mode)
      if (currentWorld === 'playa') {
      drawTrashFence();
      }
      
      // Draw wombat
      drawWombat(player.worldX, player.worldY, player.w, player.h);
      
      // Add some playa dust particles
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3})`;
        ctx.fillRect(x, y, 1, 1);
      }
      
      // Show camp exit instruction in camp mode
      if (currentWorld === 'camp') {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, canvas.height - 60, 400, 50);
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('Welcome to your camp!', 20, canvas.height - 35);
        ctx.fillText('Walk to any edge to exit and explore the playa!', 20, canvas.height - 15);
        ctx.restore();
      }
      
      // Add hallucination effects if player is under drug influence
      const hasHallucinations = player.drugEffects.activeDrugs.some(drug => drug.hallucinating);
      if (hasHallucinations) {
        drawHallucinations();
      }
      
      // Draw Molly hearts overlay
      drawMollyHearts();
      
      // Draw confetti celebration
      drawConfetti(ctx);
      
      // Draw drug hallucination effects
      drawHallucinationEffects(ctx);
      
      // Add day/night visual effects
      drawDayNightCycle();
    }
    
    function drawDayNightCycle() {
      const hour = player.time.hour;
      
      // Add stars during night time (when background is dark)
      const isNight = hour >= 18 || hour < 6;
      if (isNight) {
        drawStars();
      }
    }
    
    // Drug hallucination visual effects
    function drawHallucinationEffects(ctx) {
      // Check for active drugs with special visual effects
      const activeDrugs = player.drugEffects.activeDrugs;
      
      // Check for shrooms (color distortion)
      const hasShrooms = activeDrugs.some(drug => drug.specialEffects === 'shrooms');
      if (hasShrooms) {
        drawShroomEffects(ctx);
      }
      
      // Check for acid (extreme distortion)
      const hasAcid = activeDrugs.some(drug => drug.specialEffects === 'acid');
      if (hasAcid) {
        drawAcidEffects(ctx);
      }
      
      // Check for alcohol (blur and trails)
      const hasAlcohol = activeDrugs.some(drug => drug.specialEffects === 'alcohol');
      if (hasAlcohol) {
        drawAlcoholEffects(ctx);
      }
      
      // Check for DMT (reality breakdown)
      const hasDMT = activeDrugs.some(drug => drug.specialEffects === 'dmt');
      if (hasDMT) {
        drawDMTEffects(ctx);
      }
      
      // Check for Salvia (dimensional portal)
      const hasSalvia = activeDrugs.some(drug => drug.specialEffects === 'salvia');
      if (hasSalvia) {
        drawSalviaEffects(ctx);
      }
      
      // Check for Whip Its (vinetting tunnel vision)
      const hasWhipIts = activeDrugs.some(drug => drug.specialEffects === 'whipits');
      if (hasWhipIts) {
        drawWhipItsEffects(ctx);
      }
    }
    
    // Shroom effects - color distortion and warping
    function drawShroomEffects(ctx) {
      const time = Date.now() * 0.001;
      
      // Create color distortion overlay
      ctx.save();
      ctx.globalAlpha = 0.3;
      
      // Warp effect - create a wavy distortion
      for (let i = 0; i < 5; i++) {
        const offset = Math.sin(time + i) * 10;
        const hue = (time * 50 + i * 60) % 360;
        
        ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.2)`;
        ctx.fillRect(0, offset, canvas.width, canvas.height);
      }
      
      // Add color shifting overlay
      const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
      );
      gradient.addColorStop(0, `hsla(${(time * 30) % 360}, 80%, 70%, 0.1)`);
      gradient.addColorStop(0.5, `hsla(${(time * 45 + 120) % 360}, 60%, 50%, 0.05)`);
      gradient.addColorStop(1, `hsla(${(time * 60 + 240) % 360}, 90%, 60%, 0.1)`);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.restore();
    }
    
    // Acid effects - extreme distortion and kaleidoscope
    function drawAcidEffects(ctx) {
      const time = Date.now() * 0.002;
      
      ctx.save();
      
      // Extreme kaleidoscope effect
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = 100 + Math.sin(time + i) * 50;
        const x = canvas.width / 2 + Math.cos(angle + time) * radius;
        const y = canvas.height / 2 + Math.sin(angle + time) * radius;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(time + angle);
        ctx.scale(0.5 + Math.sin(time * 2 + i) * 0.3, 0.5 + Math.cos(time * 2 + i) * 0.3);
        
        // Rainbow colors
        const hue = (time * 100 + i * 45) % 360;
        ctx.fillStyle = `hsla(${hue}, 100%, 60%, 0.4)`;
        ctx.fillRect(-20, -20, 40, 40);
        
        ctx.restore();
      }
      
      // Psychedelic overlay
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 3; i++) {
        const wave = Math.sin(time * 3 + i) * 0.1;
        ctx.fillStyle = `hsla(${(time * 80 + i * 120) % 360}, 100%, 70%, 0.3)`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      ctx.restore();
    }
    
    // Alcohol effects - blur and motion trails
    function drawAlcoholEffects(ctx) {
      const time = Date.now() * 0.001;
      
      ctx.save();
      
      // Blur effect - multiple offset layers
      for (let i = 0; i < 3; i++) {
        const offsetX = Math.sin(time + i) * 2;
        const offsetY = Math.cos(time + i) * 2;
        const alpha = 0.1 - (i * 0.03);
        
        ctx.globalAlpha = alpha;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(offsetX, offsetY, canvas.width, canvas.height);
      }
      
      // Motion trail effect
      ctx.globalAlpha = 0.3;
      const trailGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      trailGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
      trailGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.2)');
      trailGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
      
      ctx.fillStyle = trailGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Wobble effect
      ctx.globalAlpha = 0.1;
      const wobble = Math.sin(time * 2) * 3;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.fillRect(wobble, 0, canvas.width - wobble * 2, canvas.height);
      
      ctx.restore();
    }
    
    // DMT effects - reality breakdown and geometric patterns
    function drawDMTEffects(ctx) {
      const time = Date.now() * 0.003;
      
      ctx.save();
      
      // Reality breakdown effect - multiple layers of geometric patterns
      for (let layer = 0; layer < 4; layer++) {
        const scale = 0.5 + layer * 0.2;
        const rotation = time * 0.5 + layer;
        
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(scale, scale);
        ctx.rotate(rotation);
        
        // Geometric mandala patterns
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const radius = 50 + Math.sin(time * 2 + i) * 20;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          
          ctx.fillStyle = `hsla(${(time * 120 + i * 30) % 360}, 100%, 70%, 0.4)`;
          ctx.beginPath();
          ctx.arc(x, y, 8 + Math.sin(time * 3 + i) * 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      // Reality distortion overlay
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 6; i++) {
        const wave = Math.sin(time * 4 + i) * 0.15;
        ctx.fillStyle = `hsla(${(time * 60 + i * 60) % 360}, 100%, 80%, 0.3)`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      ctx.restore();
    }
    
    // Salvia effects - dimensional portal and reality bending
    function drawSalviaEffects(ctx) {
      const time = Date.now() * 0.002;
      
      ctx.save();
      
      // Create a swirling portal effect in the center
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Portal vortex
      for (let i = 0; i < 8; i++) {
        const radius = 30 + i * 15;
        const rotation = time * 2 + i * 0.5;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        
        // Spiral arms
        for (let j = 0; j < 20; j++) {
          const spiralRadius = (j / 20) * radius;
          const spiralAngle = j * 0.3;
          const x = Math.cos(spiralAngle) * spiralRadius;
          const y = Math.sin(spiralAngle) * spiralRadius;
          
          ctx.fillStyle = `hsla(${(time * 80 + i * 45) % 360}, 100%, 60%, ${0.6 - (j / 20) * 0.5})`;
          ctx.beginPath();
          ctx.arc(x, y, 3 + Math.sin(time * 5 + j) * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      // Reality bending - screen distortion
      ctx.globalAlpha = 0.3;
      const distortion = Math.sin(time * 3) * 20;
      ctx.fillStyle = `hsla(${(time * 40) % 360}, 100%, 50%, 0.2)`;
      ctx.fillRect(-distortion, -distortion, canvas.width + distortion * 2, canvas.height + distortion * 2);
      
      ctx.restore();
    }
    
    // Whip Its effects - progressive vinetting tunnel vision
    function drawWhipItsEffects(ctx) {
      const whipitsCount = player.drugEffects.whipitsCount || 0;
      
      // Progressive vinetting based on usage count
      let vinettingStrength = 0;
      if (whipitsCount >= 5) vinettingStrength = 0.3; // Heavy vinetting
      else if (whipitsCount >= 3) vinettingStrength = 0.2; // Medium vinetting  
      else if (whipitsCount >= 1) vinettingStrength = 0.1; // Light vinetting
      
      if (vinettingStrength > 0) {
        ctx.save();
        ctx.globalAlpha = vinettingStrength;
        
        // Create vinetting effect with black corners
        const gradient = ctx.createRadialGradient(
          canvas.width / 2, canvas.height / 2, 0,
          canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
        );
        
        // Calculate tunnel size based on usage (more usage = smaller tunnel)
        const tunnelSize = Math.max(0.2, 0.8 - (whipitsCount * 0.1));
        
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)'); // Center is clear
        gradient.addColorStop(tunnelSize, 'rgba(0, 0, 0, 0)'); // Tunnel edge
        gradient.addColorStop(1, 'rgba(0, 0, 0, 1)'); // Corners are black
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.restore();
      }
    }
    
    function drawMollyHearts() {
      // Only draw hearts if Molly is active
      const hasMolly = player.drugEffects.activeDrugs.some(drug => drug.specialEffects === 'molly');
      if (!hasMolly) return;
      
      // Draw pulsating heart around player
      const time = Date.now() * 0.002;
      const playerScreenX = canvas.width / 2;
      const playerScreenY = canvas.height / 2;
      
      // Pulsating heart effect around player
      const pulseSize = 40 + Math.sin(time * 3) * 15; // 25-55px pulsating size
      const pulseAlpha = 0.6 + Math.sin(time * 4) * 0.3; // 0.3-0.9 alpha pulsating
      
      ctx.save();
      ctx.globalAlpha = pulseAlpha;
      ctx.font = `${pulseSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Add glow effect to the pulsating heart
      ctx.shadowColor = '#ff69b4';
      ctx.shadowBlur = 20;
      
      // Draw the pulsating heart
      ctx.fillText('💖', playerScreenX, playerScreenY);
      
      // Add multiple layers for more intense effect
      ctx.globalAlpha = pulseAlpha * 0.5;
      ctx.shadowBlur = 30;
      ctx.fillText('💖', playerScreenX, playerScreenY);
      
      ctx.restore();
      
      // Create streaming hearts from player character
      const heartEmojis = ['💖', '💕', '💗', '💓', '💘', '💝', '💞', '💟'];
      const heartColors = ['#ff69b4', '#ff1493', '#ff6347', '#ff4757', '#ff3838', '#ff6b9d', '#ff9ff3', '#ffc0cb'];
      
      // Spawn new hearts from player position
      if (Math.random() < 0.4) { // 40% chance each frame
        const heartEmoji = heartEmojis[Math.floor(Math.random() * heartEmojis.length)];
        const heartColor = heartColors[Math.floor(Math.random() * heartColors.length)];
        
        mollyHearts.push({
          x: playerScreenX + (Math.random() - 0.5) * 40, // Around player
          y: playerScreenY + (Math.random() - 0.5) * 40,
          vx: (Math.random() - 0.5) * 2, // Random horizontal drift
          vy: -Math.random() * 3 - 1, // Upward movement
          size: 12 + Math.random() * 8, // Random size
          opacity: 0.8 + Math.random() * 0.2,
          life: 120 + Math.random() * 60, // 2-3 seconds
          emoji: heartEmoji,
          color: heartColor
        });
      }
      
      // Draw and update floating hearts
      for (let i = mollyHearts.length - 1; i >= 0; i--) {
        const heart = mollyHearts[i];
        
        // Update heart position and life
        heart.x += heart.vx;
        heart.y += heart.vy;
        heart.life--;
        heart.opacity *= 0.99; // Fade out gradually
        
        // Remove dead hearts
        if (heart.life <= 0 || heart.opacity <= 0.1) {
          mollyHearts.splice(i, 1);
          continue;
        }
        
        // Draw heart
        ctx.save();
        ctx.globalAlpha = heart.opacity;
        ctx.font = `${heart.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Add glow effect
        ctx.shadowColor = heart.color;
        ctx.shadowBlur = 15;
        
        // Draw the heart emoji
        ctx.fillText(heart.emoji, heart.x, heart.y);
        
        ctx.restore();
      }
    }
    
    function drawStars() {
      // Simple star field
      ctx.save();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      
      // Use time-based seed for consistent stars
      const time = Math.floor(player.time.day * 24 + player.time.hour);
      
      for (let i = 0; i < 50; i++) {
        // Use time-based pseudo-random positioning
        const x = ((time + i * 7) * 17) % canvas.width;
        const y = ((time + i * 11) * 23) % canvas.height;
        const size = ((time + i * 13) % 3) + 1;
        
        ctx.fillRect(x, y, size, size);
      }
      ctx.restore();
    }

    function drawHallucinations() {
      // Color shifting effect
      ctx.save();
      ctx.globalAlpha = 0.3;
      
      // Rainbow overlay
      const time = Date.now() * 0.001;
      for (let i = 0; i < 5; i++) {
        const hue = (time * 50 + i * 72) % 360;
        ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.1)`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      // Floating geometric shapes
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 20 + 10;
        const hue = (time * 100 + i * 45) % 360;
        
        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.4)`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Wavy lines
      ctx.strokeStyle = `hsla(${(time * 80) % 360}, 90%, 70%, 0.6)`;
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 10) {
          const y = canvas.height/2 + Math.sin((x * 0.01) + time + i) * 50;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      ctx.restore();
    }

    function loop() {
      if (!gamePaused) {
        // Use the new modular game system
        game.update(16); // ~60fps
      }
      // Use the new modular game system for rendering
      game.render();
      requestAnimationFrame(loop);
    }

    // Track which modals are currently open
    let openModals = new Set();

    // Use event delegation for all action buttons
    document.addEventListener('click', (e) => {
      
      if (e.target.hasAttribute('data-action')) {
        const action = e.target.getAttribute('data-action');
        
        // Check if this action's modal is already open
        if (openModals.has(action)) {
          closeModal(action);
          return;
        }
        
        if (actions[action]) {
          openModals.add(action);
          actions[action]();
        } else {
        }
      }
    });
    
    // Function to close a modal
    function closeModal(action) {
      const modal = document.querySelector('.encounter-modal');
      if (modal) {
        document.body.removeChild(modal);
        openModals.delete(action);
      }
    }
    
    // Story mode dialogue system
    let currentDialogue = 0;
    let campNames = [];
    let granolaResponse = "";
    
    // Generate random camp names for this playthrough
    function generateCampNames() {
      // Separate camp names by personality
      const positiveNames = ['Captain Rainbow', 'Ranger Tim', 'Apollo', 'Guru', 'Hummingbird', 'Redwood', 'Meemaw', 'Shambam'];
      const neutralNames = ['Stego', 'Rocketcox', 'BB', 'Jenn', 'Dad', 'Lampchop', 'Nacho', 'Gooey'];
      
      campNames = [];
      
      // Camper 1 (complaining) - use neutral names only
      const neutralIndex = Math.floor(Math.random() * neutralNames.length);
      campNames.push(neutralNames[neutralIndex]);
      neutralNames.splice(neutralIndex, 1);
      
      // Camper 2 (confident but wrong) - use positive names
      const positiveIndex = Math.floor(Math.random() * positiveNames.length);
      campNames.push(positiveNames[positiveIndex]);
      positiveNames.splice(positiveIndex, 1);
      
      // Camper 3 (snacking) - use remaining neutral names
      if (neutralNames.length > 0) {
        const neutralIndex2 = Math.floor(Math.random() * neutralNames.length);
        campNames.push(neutralNames[neutralIndex2]);
        neutralNames.splice(neutralIndex2, 1);
      } else {
        // Fallback to positive names if neutral names are exhausted
        const positiveIndex2 = Math.floor(Math.random() * positiveNames.length);
        campNames.push(positiveNames[positiveIndex2]);
        positiveNames.splice(positiveIndex2, 1);
      }
      
      // Camper 4 (observant) - use remaining positive names
      if (positiveNames.length > 0) {
        const positiveIndex3 = Math.floor(Math.random() * positiveNames.length);
        campNames.push(positiveNames[positiveIndex3]);
      } else {
        // Fallback to remaining neutral names
        const neutralIndex3 = Math.floor(Math.random() * neutralNames.length);
        campNames.push(neutralNames[neutralIndex3]);
      }
    }
    
    // Generate random granola response
    function generateGranolaResponse() {
      const responses = [
        "Congratulations, you've packed breakfast for exactly one sparkle pony.",
        "Perfect. That'll last us until… the first dust storm. Then it's just granola soup.",
        "Great. So we'll either survive ten days… or summon the world's crunchiest art car.",
        "Radical self-reliance isn't 40 granola bars. It's forgetting them and still surviving."
      ];
      granolaResponse = responses[Math.floor(Math.random() * responses.length)];
    }
    
    const dialogues = [
      // Intro Banter
      {
        text: "Camper 1 (half-asleep): \"Wait… did anyone actually pack the rebar this year?\"",
        scene: "intro-banter"
      },
      {
        text: "Camper 2 (confident but wrong): \"Of course. I made a list. Then I lost the list. But spiritually? We're ready.\"",
        scene: "intro-banter"
      },
      {
        text: "Camper 3 (snacking already): \"I brought 40 granola bars. That's radical self-reliance, right?\"",
        scene: "intro-banter"
      },
      {
        text: "Camper 1: \"That's just… breakfast. For one day.\"",
        scene: "intro-banter"
      },
      {
        text: "Camper 4 (peering out the dusty window): \"Look at the horizon. Is that dust or is the sky already trying to kill us?\"",
        scene: "intro-banter"
      },
      {
        text: "Camper 2: \"That's just the playa saying 'welcome home.' Don't worry, we'll be fine. The RV loves us.\"",
        scene: "intro-banter"
      },
      {
        text: "[The RV shudders and coughs.]",
        scene: "intro-banter"
      },
      // The Line
      {
        text: "Camper 1 (groaning): \"How is it possible to wait three hours to drive into a city that doesn't exist?\"",
        scene: "the-line"
      },
      {
        text: "Camper 3: \"At least we have snacks. Uh… wait. We had snacks.\"",
        scene: "the-line"
      },
      {
        text: "Camper 4: \"Some guy just walked by juggling glow sticks. He's been here since sunrise.\"",
        scene: "the-line"
      },
      {
        text: "Camper 2 (excited): \"Patience, friends. We're about to be reborn as dusty desert angels.\"",
        scene: "the-line"
      }
    ];
    
    const gateChoices = {
      1: {
        text: "You drop to the ground and make a perfect dust angel, arms and legs sweeping through the playa dust.",
        result: "Gatekeeper: \"Yes! Now you are officially one of us. Dust in your lungs, dust in your soul.\"",
        karma: 1,
        coin: 0,
        time: 0
      },
      2: {
        text: "You grumble about the wait time and line management.",
        result: "Gatekeeper: \"Radical self-reliance doesn't mean whining, friend. But hey—dust provides.\" You find a crumpled $5 in the dirt.",
        karma: -1,
        coin: 1,
        time: 0
      },
      3: {
        text: "You flop dramatically to the ground and roll around in the dust, making the most elaborate dust angel ever seen.",
        result: "Gatekeeper: \"Glorious! Truly, you are the chosen dust angel.\"",
        karma: 2,
        coin: 0,
        time: 1
      }
    };
    
    function nextDialogue() {
      if (currentDialogue < dialogues.length) {
        const dialogue = dialogues[currentDialogue];
        const sceneElement = document.getElementById(dialogue.scene);
        const dialogueText = sceneElement.querySelector('.dialogue-text');
        const continueBtn = sceneElement.querySelector('.dialogue-btn:not(.skip-btn)');
        
        // Show the current scene
        document.querySelectorAll('.story-scene').forEach(scene => {
          scene.style.display = 'none';
        });
        sceneElement.style.display = 'block';
        
        // Process the dialogue text to replace camper numbers with camp names
        let processedText = dialogue.text;
        
        // Replace Camper 1, 2, 3, 4 with actual camp names
        processedText = processedText.replace(/Camper 1/g, campNames[0] || 'Camper 1');
        processedText = processedText.replace(/Camper 2/g, campNames[1] || 'Camper 2');
        processedText = processedText.replace(/Camper 3/g, campNames[2] || 'Camper 3');
        processedText = processedText.replace(/Camper 4/g, campNames[3] || 'Camper 4');
        
        // Special case: replace the granola response
        if (processedText.includes('That\'s just… breakfast. For one day.')) {
          processedText = processedText.replace('That\'s just… breakfast. For one day.', granolaResponse);
        }
        
        // Update the dialogue text
        dialogueText.innerHTML = `<p>${processedText}</p>`;
        
        // Hide skip intro button after first dialogue
        if (currentDialogue === 1) {
          const skipBtn = sceneElement.querySelector('.skip-btn');
          if (skipBtn) {
            skipBtn.style.display = 'none';
          }
        }
        
        currentDialogue++;
        
        // If this is the last dialogue, hide the continue button and show gate ritual
        if (currentDialogue >= dialogues.length) {
          if (continueBtn) {
            continueBtn.style.display = 'none';
          }
          
          // Pre-load the gate ritual text to eliminate delay
          const gateRitual = document.getElementById('gate-ritual');
          const gateText = gateRitual.querySelector('.dialogue-text');
          gateText.innerHTML = `
            <p><strong>Gatekeeper (in neon fur):</strong> "Welcome home. Step outside. Do you know what time it is?"</p>
            <p><em>It's time for the dust angel ritual - a classic Burning Man tradition!</em></p>
          `;
          
          // Immediate transition to gate ritual - no delay
          gateRitual.style.display = 'block';
        } else {
          // Show continue button for non-final dialogues
          if (continueBtn) {
            continueBtn.style.display = 'inline-block';
          }
        }
      }
    }
    
    function skipIntro() {
      // Skip directly to the game
      enterPlaya();
    }
    
    function makeChoice(choice) {
      const choiceData = gateChoices[choice];
      const resultText = document.getElementById('gate-result-text');
      
      // Apply the choice effects to player stats
      player.stats.karma += choiceData.karma;
      player.stats.coin += choiceData.coin;
      if (choiceData.time > 0) {
        player.time.hour += choiceData.time;
        if (player.time.hour >= 24) {
          player.time.hour -= 24;
          player.time.day++;
        }
      }
      
      // Show the results
      resultText.innerHTML = `
        <p><strong>${choiceData.text}</strong></p>
        <p>${choiceData.result}</p>
        <div class="stat-changes">
          ${choiceData.karma !== 0 ? `Karma: ${choiceData.karma > 0 ? '+' : ''}${choiceData.karma}<br>` : ''}
          ${choiceData.coin !== 0 ? `Coins: ${choiceData.coin > 0 ? '+' : ''}${choiceData.coin}<br>` : ''}
          ${choiceData.time !== 0 ? `Time: +${choiceData.time} hour<br>` : ''}
        </div>
        <p><em>Gatekeeper (shouting): "Welcome home! Don't forget: Leave no trace, love thy neighbor, and hydrate or die-drate!"</em></p>
      `;
      
      // Hide gate ritual, show results
      document.getElementById('gate-ritual').style.display = 'none';
      document.getElementById('gate-results').style.display = 'block';
    }
    
    function enterPlaya() {
      console.log('🌍 Entering World: Playa');
      
      // Hide story screen and show game
      document.getElementById('story-screen').style.display = 'none';
      document.getElementById('game-container').style.display = 'block';
      
      // Initialize the time system - this is critical!
      lastTimeUpdate = Date.now();
      
      // Set player to be in camp initially
      player.inCamp = true;
      
      // Initialize displays
        updateStatsDisplay();
        updateLiveActivities();
        updateTimeDisplay();
        updateInventoryDisplay();
        updateDrugEffectsDisplay();
        
        // Start the game loop
        loop();
    }
    
    // Function to show intro screen when exiting camp
    function showIntroScreen() {
      document.getElementById('game-container').style.display = 'none';
      document.getElementById('intro-screen').style.display = 'block';
    }
    
    // Function to transition from camp to playa world
    function exitCamp() {
      currentWorld = 'playa';
      campWorldGenerated = false;
      campExitTime = Date.now(); // Set timestamp for 5s cooldown

      // Detect which side of camp the player exited from and place them accordingly
      // Camp boundaries are: x: -400 to 400, y: -300 to 300
      const campMinX = -400;
      const campMaxX = 400;
      const campMinY = -300;
      const campMaxY = 300;
      
      // Determine exit direction based on player position
      let exitX, exitY;
      
      if (player.worldX < campMinX) {
        // Exited left side
        exitX = campMinX - 200; // 200 pixels left of camp
        exitY = player.worldY; // Keep same Y position
      } else if (player.worldX + player.w > campMaxX) {
        // Exited right side
        exitX = campMaxX + 200; // 200 pixels right of camp
        exitY = player.worldY; // Keep same Y position
      } else if (player.worldY < campMinY) {
        // Exited top side
        exitX = player.worldX; // Keep same X position
        exitY = campMinY - 200; // 200 pixels above camp
      } else if (player.worldY + player.h > campMaxY) {
        // Exited bottom side
        exitX = player.worldX; // Keep same X position
        exitY = campMaxY + 200; // 200 pixels below camp
      } else {
        // Fallback - shouldn't happen but just in case
        exitX = 1000; // Very far east of camp
        exitY = 0;    // Center vertically
      }
      
      // Place player at the calculated exit position
      player.worldX = exitX;
      player.worldY = exitY;
      
      console.log('🌍 Exiting World: Camp');
      
      // Only clear camp-specific content, preserve playa world
      // Remove camp wombats but keep playa NPCs
      for (let i = npcs.length - 1; i >= 0; i--) {
        if (npcs[i].isWombat) {
          npcs.splice(i, 1);
        }
      }
      
      // Remove camp decorations but keep playa decorations
      for (let i = decorations.length - 1; i >= 0; i--) {
        if (decorations[i].chunkId === 'camp') {
          decorations.splice(i, 1);
        }
      }
      
      
      // Only show intro screen the first time exiting camp
      if (!hasExitedCampBefore) {
        hasExitedCampBefore = true;
        showIntroScreen();
      } else {
        // Subsequent exits - just continue in playa mode
      }
    }

    // Function to transition from playa to camp world
    function enterCamp() {
      console.log('🌍 Entering World: Camp');
      currentWorld = 'camp';
      campWorldGenerated = false;

      // Place player in center of camp
      player.worldX = 0;   // Center of camp
      player.worldY = 0;   // Center of camp
      
      // Only clear camp-specific content, preserve playa world
      // Remove camp wombats but keep playa NPCs
      for (let i = npcs.length - 1; i >= 0; i--) {
        if (npcs[i].isWombat) {
          npcs.splice(i, 1);
        }
      }
      
      // Remove camp decorations but keep playa decorations
      for (let i = decorations.length - 1; i >= 0; i--) {
        if (decorations[i].chunkId === 'camp') {
          decorations.splice(i, 1);
        }
      }
      

      // Generate camp world (this will add camp-specific content)
      generateCampWorld();
    }
    
    // End game function - shows final screen with stats and restart button
    function endGame() {
      console.log('🎮 Game ended - showing final screen');
      
      // Calculate time played
      const actualTimePlayed = Date.now() - player.tripStats.gameStartTime;
      const actualMinutes = Math.floor(actualTimePlayed / 60000);
      const actualSeconds = Math.floor((actualTimePlayed % 60000) / 1000);
      
      // Calculate relative time (game time in minutes)
      const relativeMinutes = (player.time.day - 1) * 24 * 60 + player.time.hour * 60 + player.time.minute;
      
      // Round karma up to nearest whole number
      const finalKarma = Math.ceil(player.stats.karma);
      
      // Hide game container
      document.getElementById('game-container').style.display = 'none';
      
      // Create final screen
      const finalScreen = document.createElement('div');
      finalScreen.id = 'final-screen';
      finalScreen.className = 'intro-screen';
      finalScreen.innerHTML = `
        <div class="intro-content">
          <h1>🏜️ Your Burning Man Journey is Complete! 🏜️</h1>
          <div class="intro-text">
            <p><strong>Congratulations, wombat! You've survived the playa!</strong></p>
            
            <div class="final-stats">
              <h3>📊 Final Stats</h3>
              <div class="stat-row">
                <span class="stat-label">💰 Coins Collected:</span>
                <span class="stat-value">${Math.round(player.stats.coin)}</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">🌟 Karma Earned:</span>
                <span class="stat-value">${finalKarma}</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">⏰ Game Time Played:</span>
                <span class="stat-value">${relativeMinutes} minutes</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">🕐 Real Time Played:</span>
                <span class="stat-value">${actualMinutes}m ${actualSeconds}s</span>
              </div>
            </div>
            
            <div class="final-message">
              <p>You've experienced the full cycle of Burning Man - from arrival to the final exodus. 
              The playa has taught you many lessons about survival, community, and the importance of 
              staying hydrated!</p>
              
              <p>Thank you for playing Wombat Quest! 🐾</p>
            </div>
          </div>
          <button class="start-btn" onclick="restartGameFunction()">Play Again! 🔄</button>
        </div>
      `;
      
      // Add final screen styles
      const style = document.createElement('style');
      style.textContent = `
        .final-stats {
          background: rgba(0, 0, 0, 0.3);
          padding: 20px;
          border-radius: 10px;
          margin: 20px 0;
          border: 2px solid #ff6b35;
        }
        
        .stat-row {
          display: flex;
          justify-content: space-between;
          margin: 10px 0;
          padding: 5px 0;
          border-bottom: 1px solid rgba(255, 107, 53, 0.3);
        }
        
        .stat-row:last-child {
          border-bottom: none;
        }
        
        .stat-label {
          color: #eae9ff;
          font-weight: bold;
        }
        
        .stat-value {
          color: #ffd23f;
          font-weight: bold;
        }
        
        .final-message {
          background: rgba(0, 0, 0, 0.2);
          padding: 15px;
          border-radius: 8px;
          margin: 20px 0;
          border-left: 4px solid #8b5cf6;
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(finalScreen);
    }
    
    // Restart game function
    function restartGameFunction() {
      console.log('🔄 Restarting game');
      
      // Remove final screen
      const finalScreen = document.getElementById('final-screen');
      if (finalScreen) {
        document.body.removeChild(finalScreen);
      }
      
      // Reset player stats
      player.stats = {
        coin: 0,
        karma: 0,
        hunger: 70,
        thirst: 70,
        energy: 70,
        mood: 70
      };
      
      // Reset player time
      player.time = { day: 1, hour: 8, minute: 0 };
      
      // Reset player position
      player.worldX = 0;
      player.worldY = 0;
      player.inCamp = false;
      
      // Reset trip stats
      player.tripStats = {
        totalDrugsConsumed: 0,
        drugsTried: new Set(),
        timeHigh: 0,
        totalPlayTime: 0,
        gameStartTime: Date.now(),
        totalDistance: 0,
        lastX: 0,
        lastY: 0,
        walkingTime: 0,
        bikingTime: 0,
        artCarTime: 0,
        meditationCount: 0,
        highMoodTime: 0,
        lowMoodTime: 0,
        wellRestedTime: 0,
        exhaustedTime: 0,
        fastTime: 0,
        slowTime: 0
      };
      
      // Reset world state
      currentWorld = 'camp';
      campWorldGenerated = false;
      playaWorldGenerated = false;
      playerHomeBaseGenerated = false;
      hasExitedCampBefore = false;
      campExitTime = 0;
      worldPopulationMultiplier = 0.1;
      generatedChunks.clear();
      
      // Clear all arrays
      decorations.length = 0;
      coins.length = 0;
      waterBottles.length = 0;
      snacks.length = 0;
      bikes.length = 0;
      artCars.length = 0;
      moop.length = 0;
      drugs.length = 0;
      danceFloors.length = 0;
      artInstallations.length = 0;
      orgyDomes.length = 0;
      homeCamps.length = 0;
      centerCamps.length = 0;
      fuelStations.length = 0;
      npcs.length = 0;
      gasolineTanks.length = 0;
      
      // Reset drug effects
      player.drugEffects = {
        activeDrugs: [],
        timeMultiplier: 1.0,
        timeStopDuration: 0,
        timeAccumulator: 0,
        whipitsCount: 0
      };
      
      // Reset cooldowns
      player.cooldowns = {
        dance: 0,
        climb: 0,
        orgy: 0,
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0,
        homeSpawn: 0
      };
      
      // Reset last action times
      player.lastActionTimes = {
        chore: 0,
        shop: 0,
        temple: 0,
        man: 0
      };
      
      // Reset transport state
      ridingArtCar = null;
      ridingBike = null;
      nearbyArtCar = null;
      nearbyBike = null;
      
      // Reset time system
      lastTimeUpdate = 0;
      lastDisappearingDay = 0;
      lastAnnouncedDay = 0;
      
      // Reset open modals
      openModals.clear();
      
      // Start fresh with story mode
      initializeStoryMode();
    }

    // Intro screen functionality
    const startStoryBtn = document.getElementById('start-story-btn');
    const startSimulationBtn = document.getElementById('start-simulation-btn');
    const introScreen = document.getElementById('intro-screen');
    const storyScreen = document.getElementById('story-screen');
    const gameContainer = document.getElementById('game-container');
    
    // Initialize story mode immediately on page load
    function initializeStoryMode() {
      
      // Generate random camp names and granola response for this playthrough
      generateCampNames();
      generateGranolaResponse();
      
      // Reset dialogue system
      currentDialogue = 0;
      document.querySelectorAll('.story-scene').forEach(scene => {
        scene.style.display = 'none';
      });
      document.getElementById('intro-banter').style.display = 'block';
      
      // Initialize first dialogue with camp names
      const firstDialogue = dialogues[0];
      let processedText = firstDialogue.text;
      processedText = processedText.replace(/Camper 1/g, campNames[0] || 'Camper 1');
      processedText = processedText.replace(/Camper 2/g, campNames[1] || 'Camper 2');
      processedText = processedText.replace(/Camper 3/g, campNames[2] || 'Camper 3');
      processedText = processedText.replace(/Camper 4/g, campNames[3] || 'Camper 4');
      
      const dialogueText = document.getElementById('intro-banter').querySelector('.dialogue-text');
      dialogueText.innerHTML = `<p>${processedText}</p>`;
      currentDialogue = 1;
    }
    
    // Navigate from intro to simulation (when exiting camp)
    if (startStoryBtn && introScreen && storyScreen) {
      startStoryBtn.addEventListener('click', () => {
        introScreen.style.display = 'none';
        enterPlaya();
      });
    }
    
    // Note: Story mode to simulation navigation is now handled by the enterPlaya() function
    
    // Prevent the original "Start Simulation" button from starting the timer
    if (startSimulationBtn) {
      startSimulationBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // Don't start the game - let the story mode handle it
      });
    }

    // Pause button functionality
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) {
      pauseBtn.addEventListener('click', () => {
        gamePaused = !gamePaused;
        pauseBtn.classList.toggle('paused', gamePaused);
      });
    }
    
    // Initialize story mode immediately
    if (storyScreen) {
      initializeStoryMode();
    } else {
      // Fallback if story elements aren't found - show game immediately
      if (gameContainer) gameContainer.style.display = 'block';
      
      // Initialize displays
      updateStatsDisplay();
      updateTimeDisplay();
      updateInventoryDisplay();
      updateDrugEffectsDisplay();
      
      // Start the game loop
      loop();
    }
    
    // Fix button state on window resize
    window.addEventListener('resize', () => {
      updateTransportButtons();
    });

    // Debug function to reset time system if it gets stuck
    window.resetTimeSystem = function() {
      player.drugEffects.timeStopDuration = 0;
      player.drugEffects.timeAccumulator = 0;
      player.drugEffects.activeDrugs = [];
      lastTimeUpdate = Date.now();
      // Only update time display in playa mode
      if (currentWorld === 'playa') {
        updateTimeDisplay();
      }
    };
    
    // Debug function to check time system status
    window.debugTimeSystem = function() {
      console.log('=== TIME SYSTEM DEBUG ===');
      console.log('Current time:', player.time.day, player.time.hour, player.time.minute);
      console.log('Active drugs:', player.drugEffects.activeDrugs.length);
      player.drugEffects.activeDrugs.forEach((drug, i) => {
        console.log(`Drug ${i}: ${drug.type}, timeMultiplier: ${drug.timeMultiplier}, duration: ${drug.duration}`);
      });
      
      let timeMultiplier = 1.0;
      player.drugEffects.activeDrugs.forEach(drug => {
        if (drug.timeMultiplier !== undefined && drug.timeMultiplier !== 0) {
          timeMultiplier *= drug.timeMultiplier;
        }
      });
      
      if (player.drugEffects.timeStopDuration > 0) {
        timeMultiplier = 0;
      }
      
      console.log('Total time multiplier:', timeMultiplier);
      console.log('Time stop duration:', player.drugEffects.timeStopDuration);
      console.log('Time accumulator:', player.drugEffects.timeAccumulator);
      console.log('Last time update:', new Date(lastTimeUpdate));
      console.log('========================');
    };
    
    // Initialize immediately
    
    resizeCanvas(); // Make sure canvas is properly sized
    // Game loop will be started from intro screen button
    
    // Story mode dialogue system - make these functions available globally
    // These functions are already defined earlier in the file, but we need to make sure they're accessible
    // The original functions should work, but let's ensure they're in global scope if needed
    
    // Make sure the dialogue functions are available globally
    if (typeof window.nextDialogue === 'undefined') {
      window.nextDialogue = nextDialogue;
    }
    if (typeof window.skipIntro === 'undefined') {
      window.skipIntro = skipIntro;
    }
    if (typeof window.makeChoice === 'undefined') {
      window.makeChoice = makeChoice;
    }
    if (typeof window.enterPlaya === 'undefined') {
      window.enterPlaya = enterPlaya;
    }
    
    // Initialize the dialogue system
    if (typeof generateCampNames === 'function') {
      generateCampNames();
      console.log('Camp names generated:', campNames);
    }
    if (typeof generateGranolaResponse === 'function') {
      generateGranolaResponse();
      console.log('Granola response generated:', granolaResponse);
    }
    
    // Debug: Check if functions are available
    console.log('nextDialogue available:', typeof window.nextDialogue);
    console.log('skipIntro available:', typeof window.skipIntro);
    console.log('makeChoice available:', typeof window.makeChoice);
    console.log('gateChoices available:', typeof gateChoices);
  </script>
</body>
</html>
